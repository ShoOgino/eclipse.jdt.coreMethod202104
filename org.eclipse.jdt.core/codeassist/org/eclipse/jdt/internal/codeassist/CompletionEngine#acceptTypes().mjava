	private void acceptTypes() {
		if(this.acceptedTypes == null) return;
		
		int length = this.acceptedTypes.size();
		
		if(length == 0) return;
		
		HashtableOfObject onDemandFound = new HashtableOfObject();
		
		next : for (int i = 0; i < length; i++) {
			AcceptedType acceptedType = (AcceptedType)this.acceptedTypes.elementAt(i);
			char[] packageName = acceptedType.packageName;
			char[] simpleTypeName = acceptedType.simpleTypeName;
			char[][] enclosingTypeNames = acceptedType.enclosingTypeNames;
			int modifiers = acceptedType.modifiers;
			int accessibility = acceptedType.accessibility;
			
			char[] typeName;
			char[] flatEnclosingTypeNames;
			if(enclosingTypeNames == null || enclosingTypeNames.length == 0) {
				flatEnclosingTypeNames = null;
				typeName = simpleTypeName;
			} else {
				flatEnclosingTypeNames = CharOperation.concatWith(acceptedType.enclosingTypeNames, '.');
				typeName = CharOperation.concat(flatEnclosingTypeNames, simpleTypeName, '.');
			}
			char[] fullyQualifiedName = CharOperation.concat(packageName, typeName, '.');
			
			if (this.knownTypes.containsKey(fullyQualifiedName)) continue next;
	
			this.knownTypes.put(fullyQualifiedName, this);
			
			if (this.resolvingImports) {
				char[] completionName;
				
				if(this.resolvingStaticImports) {
					if(enclosingTypeNames == null || enclosingTypeNames.length == 0) {
						completionName = CharOperation.concat(fullyQualifiedName, new char[] { '.' });
					} else if ((modifiers & IConstants.AccStatic) == 0) {
						continue next;
					} else {
						completionName = CharOperation.concat(fullyQualifiedName, new char[] { ';' });
					}
				} else {
					completionName = CharOperation.concat(fullyQualifiedName, new char[] { ';' });
				}
				
				int relevance = computeBaseRelevance();
				relevance += computeRelevanceForInterestingProposal();
				relevance += computeRelevanceForRestrictions(accessibility);
				if(insideQualifiedReference) {
					relevance += computeRelevanceForCaseMatching(this.completionToken, fullyQualifiedName);
				} else {
					relevance += computeRelevanceForCaseMatching(this.completionToken, simpleTypeName);
				}
				
				this.noProposal = false;
				if(!this.requestor.isIgnored(CompletionProposal.TYPE_REF)) {
					createTypeProposal(packageName, typeName, modifiers, accessibility, completionName, relevance);
				}
			} else {
				if(!this.importCachesInitialized) {
					this.initializeImportCaches();
				}
			
				for (int j = 0; j < this.importCacheCount; j++) {
					char[][] importName = this.importsCache[j];
					if(CharOperation.equals(typeName, importName[0])) {
						proposeType(
								packageName,
								simpleTypeName,
								modifiers,
								accessibility,
								typeName,
								fullyQualifiedName,
								!CharOperation.equals(fullyQualifiedName, importName[1]));
						continue next;
					}
				}
				
				
				if ((enclosingTypeNames == null || enclosingTypeNames.length == 0 ) && CharOperation.equals(this.currentPackageName, packageName)) {
					proposeType(
							packageName,
							simpleTypeName,
							modifiers,
							accessibility,
							typeName,
							fullyQualifiedName,
							false);
					continue next;
				} else {
					char[] fullyQualifiedEnclosingTypeOrPackageName = null;
			
					AcceptedType foundType = null;
					if((foundType = (AcceptedType)onDemandFound.get(simpleTypeName)) == null) {
						for (int j = 0; j < this.onDemandImportCacheCount; j++) {
							ImportBinding importBinding = this.onDemandImportsCache[j];

							char[][] importName = importBinding.compoundName;
							char[] importFlatName = CharOperation.concatWith(importName, '.');
						
							if(fullyQualifiedEnclosingTypeOrPackageName == null) {
								if(enclosingTypeNames != null && enclosingTypeNames.length != 0) {
									fullyQualifiedEnclosingTypeOrPackageName =
										CharOperation.concat(
												packageName,
												flatEnclosingTypeNames,
												'.');
								} else {
									fullyQualifiedEnclosingTypeOrPackageName =
										packageName;
								}
							}
							if(CharOperation.equals(fullyQualifiedEnclosingTypeOrPackageName, importFlatName)) {
								if(importBinding.isStatic()) {
									if((modifiers & IConstants.AccStatic) != 0) {
										acceptedType.qualifiedTypeName = typeName;
										acceptedType.fullyQualifiedName = fullyQualifiedName;
										onDemandFound.put(
												simpleTypeName,
												acceptedType);
										continue next;
									}
								} else {
									acceptedType.qualifiedTypeName = typeName;
									acceptedType.fullyQualifiedName = fullyQualifiedName;
									onDemandFound.put(
											simpleTypeName,
											acceptedType);
									continue next;
								}
							}
						}
					} else if(!foundType.mustBeQualified){
						done : for (int j = 0; j < this.onDemandImportCacheCount; j++) {
							ImportBinding importBinding = this.onDemandImportsCache[j];

							char[][] importName = importBinding.compoundName;
							char[] importFlatName = CharOperation.concatWith(importName, '.');
						
							if(fullyQualifiedEnclosingTypeOrPackageName == null) {
								if(enclosingTypeNames != null && enclosingTypeNames.length != 0) {
									fullyQualifiedEnclosingTypeOrPackageName =
										CharOperation.concat(
												packageName,
												flatEnclosingTypeNames,
												'.');
								} else {
									fullyQualifiedEnclosingTypeOrPackageName =
										packageName;
								}
							}
							if(CharOperation.equals(fullyQualifiedEnclosingTypeOrPackageName, importFlatName)) {
								if(importBinding.isStatic()) {
									if((modifiers & IConstants.AccStatic) != 0) {
										foundType.mustBeQualified = true;
										break done;
									}
								} else {
									foundType.mustBeQualified = true;
									break done;
								}
							}
						}
					}
					proposeType(
							packageName,
							simpleTypeName,
							modifiers,
							accessibility,
							typeName,
							fullyQualifiedName,
							true);
				}
			}
		}
		char[][] keys = onDemandFound.keyTable;
		Object[] values = onDemandFound.valueTable;
		int max = keys.length;
		for (int i = 0; i < max; i++) {
			if(keys[i] != null) {
				AcceptedType value = (AcceptedType) values[i];
				if(value != null) {
					proposeType(
							value.packageName,
							value.simpleTypeName,
							value.modifiers,
							value.accessibility,
							value.qualifiedTypeName,
							value.fullyQualifiedName,
							value.mustBeQualified);
				}
			}
		}
		this.acceptedTypes = null; // reset
	}

