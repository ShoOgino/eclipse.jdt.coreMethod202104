	/* Optimized (java) code generation for string concatenations that involve StringBuffer
	 * creation: going through this path means that there is no need for a new StringBuffer
	 * creation, further operands should rather be only appended to the current one.
	 */
	public void generateOptimizedStringConcatenationCreation(
		BlockScope blockScope,
		CodeStream codeStream,
		int typeID) {

		codeStream.newStringContatenation();
		codeStream.dup();
		switch (typeID) {
			case T_JavaLangObject :
			case T_undefined :
				// in the case the runtime value of valueOf(Object) returns null, we have to use append(Object) instead of directly valueOf(Object)
				// append(Object) returns append(valueOf(Object)), which means that the null case is handled by the next case.
				codeStream.invokeStringConcatenationDefaultConstructor();
				generateCode(blockScope, codeStream, true);
				codeStream.invokeStringConcatenationAppendForType(TypeIds.T_JavaLangObject);
				return;
			case T_JavaLangString :
			case T_null :
				if (this.constant != Constant.NotAConstant) {
					String stringValue = this.constant.stringValue();
					if (stringValue.length() == 0) {  // optimize ""+<str> 
						codeStream.invokeStringConcatenationDefaultConstructor();
						return;
					}
					codeStream.ldc(stringValue);
				} else {
					// null case is not a constant
					generateCode(blockScope, codeStream, true);
					codeStream.invokeStringValueOf(TypeIds.T_JavaLangObject);
				}
				break;
			default :
				generateCode(blockScope, codeStream, true);
				codeStream.invokeStringValueOf(typeID);
		}
		codeStream.invokeStringConcatenationStringConstructor();
	}

