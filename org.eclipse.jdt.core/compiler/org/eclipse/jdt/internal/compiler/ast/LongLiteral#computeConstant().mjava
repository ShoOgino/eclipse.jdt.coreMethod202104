public void computeConstant() {
	//the overflow (when radix=10) is tested using the fact that
	//the value should always grow during its computation
	int length = source.length - 1; //minus one because the last char is 'l' or 'L'
	
	long computedValue ;
	if (source[0] == '0') {
		if (length == 1) {
			constant = LongConstant.fromValue(0L);
			return;
		}
		final int shift,radix;
		int j ;
		if ( (source[1] == 'x') || (source[1] == 'X') ) {
			shift = 4 ; j = 2; radix = 16;
		} else {
			shift = 3 ; j = 1; radix = 8;
		}
		int nbDigit = 0;
		while (source[j]=='0') {
			j++; //jump over redondant zero
			if ( j == length) {
				//watch for 0000000000000L
				constant = LongConstant.fromValue(0L);
				return ;
			}
		}
				
		int digitValue ;
		if ((digitValue = ScannerHelper.digit(source[j++],radix)) < 0 ) {
			constant = FORMAT_ERROR; return ;
		}
		if (digitValue >= 8)
			nbDigit = 4;
		else if (digitValue >= 4)
			nbDigit = 3;
		else if (digitValue >= 2)
			nbDigit = 2;
		else
			nbDigit = 1; //digitValue is not 0
		computedValue = digitValue ;
		while (j<length) {
			if ((digitValue = ScannerHelper.digit(source[j++],radix)) < 0) {
				constant = FORMAT_ERROR; return ;
			}
			if ((nbDigit += shift) > 64)
				return /*constant stays null*/ ;
			computedValue = (computedValue<<shift) | digitValue ;
		}
	} else {
		//-----------case radix=10-----------------
		long previous = 0;
		computedValue = 0;
		final long limit = Long.MAX_VALUE / 10; // needed to check prior to the multiplication
		for (int i = 0 ; i < length; i++) {
			int digitValue ;	
			if ((digitValue = ScannerHelper.digit(source[i], 10)) < 0 ) return /*constant stays null*/;
			previous = computedValue;
			if (computedValue > limit)
				return /*constant stays null*/;
			computedValue *= 10;
			if ((computedValue + digitValue) > Long.MAX_VALUE)
				return /*constant stays null*/;
			computedValue += digitValue;
			if (previous > computedValue)
				return /*constant stays null*/;
		}
	}
	constant = LongConstant.fromValue(computedValue);
}

