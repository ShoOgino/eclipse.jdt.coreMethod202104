	public TypeBinding resolveType(BlockScope scope) {

		// added for code assist...cannot occur with 'normal' code
		if (anonymousType == null && enclosingInstance == null) {
			return super.resolveType(scope);
		}

		// Propagate the type checking to the arguments, and checks if the constructor is defined.
		// ClassInstanceCreationExpression ::= Primary '.' 'new' SimpleName '(' ArgumentListopt ')' ClassBodyopt
		// ClassInstanceCreationExpression ::= Name '.' 'new' SimpleName '(' ArgumentListopt ')' ClassBodyopt
		// ==> by construction, when there is an enclosing instance the typename may NOT be qualified
		// ==> therefore by construction the type is always a SingleTypeReferenceType instead of being either 
		// sometime a SingleTypeReference and sometime a QualifedTypeReference

		constant = NotAConstant;
		TypeBinding enclosingInstanceType = null;
		TypeBinding receiverType = null;
		boolean hasError = false;
		boolean argsContainCast = false;
		if (anonymousType == null) { //----------------no anonymous class------------------------	
			if ((enclosingInstanceType = enclosingInstance.resolveType(scope)) == null){
				hasError = true;
			} else if (enclosingInstanceType.isBaseType() || enclosingInstanceType.isArrayType()) {
				scope.problemReporter().illegalPrimitiveOrArrayTypeForEnclosingInstance(
					enclosingInstanceType,
					enclosingInstance);
				hasError = true;
			} else if ((receiverType = ((SingleTypeReference) type).resolveTypeEnclosing(
							scope,
							(ReferenceBinding) enclosingInstanceType)) == null) {
				hasError = true;
			}
			// will check for null after args are resolved
			TypeBinding[] argumentTypes = NoParameters;
			if (arguments != null) {
				int length = arguments.length;
				argumentTypes = new TypeBinding[length];
				for (int i = 0; i < length; i++) {
					Expression argument = this.arguments[i];
					if (argument instanceof CastExpression) {
						argument.bits |= IgnoreNeedForCastCheckMASK; // will check later on
						argsContainCast = true;
					}
					if ((argumentTypes[i] = argument.resolveType(scope)) == null){
						hasError = true;
					}
				}
			}
			// limit of fault-tolerance
			if (hasError) return receiverType;
			ReferenceBinding allocationType = (ReferenceBinding) receiverType;
			if (!receiverType.canBeInstantiated()) {
				scope.problemReporter().cannotInstantiate(type, receiverType);
				return this.resolvedType = receiverType;
			}
			if ((this.binding = scope.getConstructor(allocationType, argumentTypes, this)).isValidBinding()) {
				if (isMethodUseDeprecated(binding, scope)) {
					scope.problemReporter().deprecatedMethod(this.binding, this);
				}
				if (arguments != null) {
					for (int i = 0; i < arguments.length; i++) {
						arguments[i].implicitWidening(this.binding.parameters[i], argumentTypes[i]);
					}
					if (argsContainCast) {
						CastExpression.checkNeedForArgumentCasts(scope, null, allocationType, binding, this.arguments, argumentTypes, this);
					}
				}
			} else {
				if (this.binding.declaringClass == null) {
					this.binding.declaringClass = allocationType;
				}
				scope.problemReporter().invalidConstructor(this, this.binding);
				return this.resolvedType = receiverType;
			}

			// The enclosing instance must be compatible with the innermost enclosing type
			ReferenceBinding expectedType = this.binding.declaringClass.enclosingType();
			if (enclosingInstanceType.isCompatibleWith(expectedType)) {
				return receiverType;
			}
			scope.problemReporter().typeMismatchErrorActualTypeExpectedType(
				this.enclosingInstance,
				enclosingInstanceType,
				expectedType);
			return this.resolvedType = receiverType;
		}

		//--------------there is an anonymous type declaration-----------------
		if (this.enclosingInstance != null) {
			if ((enclosingInstanceType = this.enclosingInstance.resolveType(scope)) == null) {
				hasError = true;
			} else if (enclosingInstanceType.isBaseType() || enclosingInstanceType.isArrayType()) {
				scope.problemReporter().illegalPrimitiveOrArrayTypeForEnclosingInstance(
					enclosingInstanceType,
					this.enclosingInstance);
				hasError = true;
			} else {
				receiverType = ((SingleTypeReference) type).resolveTypeEnclosing(
										scope,
										(ReferenceBinding) enclosingInstanceType);				
			}
		} else {
			receiverType = type.resolveType(scope);
		}
		if (receiverType == null) {
			hasError = true;
		} else if (((ReferenceBinding) receiverType).isFinal()) {
			scope.problemReporter().anonymousClassCannotExtendFinalClass(type, receiverType);
			hasError = true;
		}
		TypeBinding[] argumentTypes = NoParameters;
		if (arguments != null) {
			int length = arguments.length;
			argumentTypes = new TypeBinding[length];
			for (int i = 0; i < length; i++) {
				Expression argument = this.arguments[i];
				if (argument instanceof CastExpression) {
					argument.bits |= IgnoreNeedForCastCheckMASK; // will check later on
					argsContainCast = true;
				}
				if ((argumentTypes[i] = argument.resolveType(scope)) == null) {
					hasError = true;
				}
			}
		}
		// limit of fault-tolerance
		if (hasError) {
			return this.resolvedType = receiverType;
		}

		// an anonymous class inherits from java.lang.Object when declared "after" an interface
		this.superTypeBinding =
			receiverType.isInterface() ? scope.getJavaLangObject() : (ReferenceBinding) receiverType;
		MethodBinding inheritedBinding =
			scope.getConstructor(this.superTypeBinding, argumentTypes, this);
		if (!inheritedBinding.isValidBinding()) {
			if (inheritedBinding.declaringClass == null) {
				inheritedBinding.declaringClass = this.superTypeBinding;
			}
			scope.problemReporter().invalidConstructor(this, inheritedBinding);
			return null;
		}
		if (enclosingInstance != null) {
			if (!enclosingInstanceType.isCompatibleWith(inheritedBinding.declaringClass.enclosingType())) {
				scope.problemReporter().typeMismatchErrorActualTypeExpectedType(
					enclosingInstance,
					enclosingInstanceType,
					inheritedBinding.declaringClass.enclosingType());
				return null;
			}
		}

		// this promotion has to be done somewhere: here or inside the constructor of the
		// anonymous class. We do it here while the constructor of the inner is then easier.
		if (arguments != null) {
			for (int i = 0; i < arguments.length; i++) {
				arguments[i].implicitWidening(inheritedBinding.parameters[i], argumentTypes[i]);
			}
			if (argsContainCast) {
				CastExpression.checkNeedForArgumentCasts(scope, null, this.superTypeBinding, inheritedBinding, this.arguments, argumentTypes, this);
			}
		}
		// Update the anonymous inner class : superclass, interface  
		scope.addAnonymousType(anonymousType, (ReferenceBinding) receiverType);
		anonymousType.resolve(scope);
		binding = anonymousType.createsInternalConstructorWithBinding(inheritedBinding);
		return this.resolvedType = anonymousType.binding; // 1.2 change
	}

