	/**
	 * Resolve annotations, and check duplicates, answers combined tagBits
	 * for recognized standard annotations. Return null if nothing new is
	 * resolved.
	 */
	public static AnnotationBinding [] resolveAnnotations(BlockScope scope, Annotation[] sourceAnnotations, Binding recipient, boolean copySE8AnnotationsToType) {
		AnnotationBinding[] annotations = null;
		int length = sourceAnnotations == null ? 0 : sourceAnnotations.length;
		if (recipient != null) {
			switch (recipient.kind()) {
				case Binding.PACKAGE :
					PackageBinding packageBinding = (PackageBinding) recipient;
					if ((packageBinding.tagBits & TagBits.AnnotationResolved) != 0) return annotations;
					packageBinding.tagBits |= (TagBits.AnnotationResolved | TagBits.DeprecatedAnnotationResolved);
					break;
				case Binding.TYPE :
				case Binding.GENERIC_TYPE :
					ReferenceBinding type = (ReferenceBinding) recipient;
					if ((type.tagBits & TagBits.AnnotationResolved) != 0) return annotations;
					type.tagBits |= (TagBits.AnnotationResolved | TagBits.DeprecatedAnnotationResolved);
					if (length > 0) {
						annotations = new AnnotationBinding[length];
						type.setAnnotations(annotations);
					}
					break;
				case Binding.METHOD :
					MethodBinding method = (MethodBinding) recipient;
					if ((method.tagBits & TagBits.AnnotationResolved) != 0) return annotations;
					method.tagBits |= (TagBits.AnnotationResolved | TagBits.DeprecatedAnnotationResolved);
					if (length > 0) {
						annotations = new AnnotationBinding[length];
						method.setAnnotations(annotations);
					}
					break;
				case Binding.FIELD :
					FieldBinding field = (FieldBinding) recipient;
					if ((field.tagBits & TagBits.AnnotationResolved) != 0) return annotations;
					field.tagBits |= (TagBits.AnnotationResolved | TagBits.DeprecatedAnnotationResolved);
					if (length > 0) {
						annotations = new AnnotationBinding[length];
						field.setAnnotations(annotations);
					}
					break;
				case Binding.LOCAL :
					LocalVariableBinding local = (LocalVariableBinding) recipient;
					if ((local.tagBits & TagBits.AnnotationResolved) != 0) return annotations;
					local.tagBits |= (TagBits.AnnotationResolved | TagBits.DeprecatedAnnotationResolved);
					if (length > 0) {
						annotations = new AnnotationBinding[length];
						local.setAnnotations(annotations, scope);
					}
					break;
				case Binding.TYPE_PARAMETER :
				case Binding.TYPE_USE :
					// deliberately don't set the annotation resolved tagbits, it is not material and also we are working with a dummy static object.
					annotations = new AnnotationBinding[length];
					break;
				default :
					return annotations;
			}
		}
		if (sourceAnnotations == null)
			return annotations;
		for (int i = 0; i < length; i++) {
			Annotation annotation = sourceAnnotations[i];
			final Binding annotationRecipient = annotation.recipient;
			if (annotationRecipient != null && recipient != null) {
				// only local and field can share annnotations and their types.
				switch (recipient.kind()) {
					case Binding.TYPE_USE:
						if (annotations != null) {
							// need to fill the instances array
							for (int j = 0; j < length; j++) {
								annotations[j] = sourceAnnotations[j].getCompilerAnnotation();
							}
						}
						break;
					case Binding.FIELD :
						FieldBinding field = (FieldBinding) recipient;
						if (!(annotationRecipient instanceof FieldBinding))
							break;
						field.tagBits = ((FieldBinding) annotationRecipient).tagBits;
						if (annotations != null) {
							// need to fill the instances array
							for (int j = 0; j < length; j++) {
								Annotation annot = sourceAnnotations[j];
								annotations[j] = annot.getCompilerAnnotation();
							}
						}
						break;
					case Binding.LOCAL :
						LocalVariableBinding local = (LocalVariableBinding) recipient;
						if (!(annotationRecipient instanceof LocalVariableBinding))
							break;
						long otherLocalTagBits = ((LocalVariableBinding) annotationRecipient).tagBits;
						local.tagBits = otherLocalTagBits;
						if ((otherLocalTagBits & TagBits.AnnotationSuppressWarnings) == 0) {
							// None of the annotations is a SuppressWarnings annotation
							// need to fill the instances array
							if (annotations != null) {
								for (int j = 0; j < length; j++) {
									Annotation annot = sourceAnnotations[j];
									annotations[j] = annot.getCompilerAnnotation();
								}
							}
						} else if (annotations != null) {
							// One of the annotations at least is a SuppressWarnings annotation
							LocalDeclaration localDeclaration = local.declaration;
							int declarationSourceEnd = localDeclaration.declarationSourceEnd;
							int declarationSourceStart = localDeclaration.declarationSourceStart;
							for (int j = 0; j < length; j++) {
								Annotation annot = sourceAnnotations[j];
								/*
								 * Annotations are shared between two locals, but we still need to record
								 * the suppress annotation range for the second local
								 */
								AnnotationBinding annotationBinding = annot.getCompilerAnnotation();
								annotations[j] = annotationBinding;
								if (annotationBinding != null) {
									final ReferenceBinding annotationType = annotationBinding.getAnnotationType();
									if (annotationType != null && annotationType.id == TypeIds.T_JavaLangSuppressWarnings) {
										annot.recordSuppressWarnings(scope, declarationSourceStart, declarationSourceEnd, scope.compilerOptions().suppressWarnings);
									}
								}
							}
						}
						break;
					default:
						if (annotations != null) {
							annotations[i] = annotation.getCompilerAnnotation();
						}
						break;
				}
				return annotations;
			} else {
				annotation.recipient = recipient;
				annotation.resolveType(scope);
				// null if receiver is a package binding
				if (annotations != null) {
					annotations[i] = annotation.getCompilerAnnotation();
				}
			}
		}

		if (copySE8AnnotationsToType)
			copySE8AnnotationsToType(scope, recipient, sourceAnnotations);

		if (annotations != null && length > 0 && recipient != null && recipient.isAnnotationType()) {
			// See if this is meta-annotated as repeatable and if so validate constraints.
			for (int i = 0; i < length; i++) {
				Annotation annotation = sourceAnnotations[i];
				MemberValuePair[] valuePairs = annotation.memberValuePairs();
				ReferenceBinding annotationType = annotations[i] != null ? annotations[i].getAnnotationType() : null;
				if (annotationType != null && annotationType.id == TypeIds.T_JavaLangAnnotationRepeatable && valuePairs != null && valuePairs.length > 0) {
					annotation.checkRepeatableAnnotation(valuePairs[0], scope, valuePairs[0].compilerElementPair.value);
				}
			}
		}
		
		// check duplicate annotations
		if (annotations != null && length > 1) {
			AnnotationBinding[] distinctAnnotations = annotations; // only copy after 1st duplicate is detected
			Map implicitContainerAnnotations = null;
			for (int i = 0; i < length; i++) {
				AnnotationBinding annotation = distinctAnnotations[i];
				if (annotation == null) continue;
				ReferenceBinding annotationType = annotation.getAnnotationType();
				boolean foundDuplicate = false;
				for (int j = i+1; j < length; j++) {
					AnnotationBinding otherAnnotation = distinctAnnotations[j];
					if (otherAnnotation == null) continue;
					if (otherAnnotation.getAnnotationType() == annotationType) {
						if (annotationType.isRepeatableAnnotation()) {
							ReferenceBinding resolvedContainer = annotationType.resolveContainerAnnotation();
							if (resolvedContainer != null) {
								// Since this is a repeated annotation, we need to check if the container is also used - so store it
								// in a map of (container's ReferenceBinding -> the repeated source Annotation)
								if (implicitContainerAnnotations == null) implicitContainerAnnotations = new HashMap(3);
								implicitContainerAnnotations.put(resolvedContainer, sourceAnnotations[i]);
								// Validate the repeated *use* of a repeatable annotation.
								Annotation.checkContainingAnnotation(sourceAnnotations[i], scope, resolvedContainer, annotationType);
							}
						} else {
							foundDuplicate = true;
							if (distinctAnnotations == annotations) {
								System.arraycopy(distinctAnnotations, 0, distinctAnnotations = new AnnotationBinding[length], 0, length);
							}
							distinctAnnotations[j] = null; // report it only once
							scope.problemReporter().duplicateAnnotation(sourceAnnotations[j], scope.compilerOptions().sourceLevel);
						}
					}
				}
				if (foundDuplicate) {
					scope.problemReporter().duplicateAnnotation(sourceAnnotations[i], scope.compilerOptions().sourceLevel);
				}
			}
			// Check for presence of repeating annotation together with the containing annotation
			if (implicitContainerAnnotations != null) {
				for (int i = 0; i < length; i++) {
					if (distinctAnnotations[i] == null) continue;
					Annotation annotation = sourceAnnotations[i];
					ReferenceBinding annotationType = distinctAnnotations[i].getAnnotationType();
					if (implicitContainerAnnotations.containsKey(annotationType)) {
						scope.problemReporter().repeatedAnnotationWithContainer((Annotation) implicitContainerAnnotations.get(annotationType), annotation);
					}
				}
			}
		}
		return annotations;
	}

