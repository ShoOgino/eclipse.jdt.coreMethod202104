// return: severity: 0 = no problem; 1 = unchecked conversion wrt type detail; 2 = conflicting annotations
// nullStatus: we are only interested in NULL or NON_NULL, -1 indicates that we are in a recursion, where flow info is ignored
protected int findNullTypeAnnotationMismatch(TypeBinding requiredType, TypeBinding providedType, int nullStatus) {
	int severity = 0;
	if (requiredType instanceof ArrayBinding) {
		long[] requiredDimsTagBits = ((ArrayBinding)requiredType).nullTagBitsPerDimension;
		if (requiredDimsTagBits != null) {
			int dims = requiredType.dimensions();
			if (requiredType.dimensions() == providedType.dimensions()) {
				long[] providedDimsTagBits = ((ArrayBinding)providedType).nullTagBitsPerDimension;
				if (providedDimsTagBits == null) {
					severity = 1; // required is annotated, provided not, need unchecked conversion
				} else {
					for (int i=0; i<dims; i++) {
						long requiredBits = requiredDimsTagBits[i] & TagBits.AnnotationNullMASK;
						long providedBits = providedDimsTagBits[i] & TagBits.AnnotationNullMASK;
						if (i > 0)
							nullStatus = -1; // don't use beyond the outermost dimension
						severity = Math.max(severity, computeNullProblemSeverity(requiredBits, providedBits, nullStatus));
						if (severity == 2)
							return severity;
					}
				}
			} else if (providedType.id == TypeIds.T_null) {
				if (dims > 0 && requiredDimsTagBits[0] == TagBits.AnnotationNonNull)
					return 2;
			}
		}
	} else if (requiredType.hasNullTypeAnnotations() || providedType.hasNullTypeAnnotations()) {
		long requiredBits = requiredType.tagBits & TagBits.AnnotationNullMASK;
		if (requiredBits != TagBits.AnnotationNullable // nullable lhs accepts everything, ...
				|| nullStatus == -1) // only at detail/recursion even nullable must be matched exactly
		{
			long providedBits = providedType.tagBits & TagBits.AnnotationNullMASK;
			severity = computeNullProblemSeverity(requiredBits, providedBits, nullStatus);
		}
		if (severity < 2) {
			if (requiredType.isParameterizedType()  && providedType.isParameterizedType()) { // TODO(stephan): handle providedType.isRaw()
				TypeBinding[] requiredArguments = ((ParameterizedTypeBinding) requiredType).arguments;
				TypeBinding[] providedArguments = ((ParameterizedTypeBinding) providedType).arguments;
				if (requiredArguments != null && providedArguments != null && requiredArguments.length == providedArguments.length) {
					for (int i = 0; i < requiredArguments.length; i++) {
						severity = Math.max(severity, findNullTypeAnnotationMismatch(requiredArguments[i], providedArguments[i], -1));
						if (severity == 2)
							return severity;
					}
				}
			} else 	if (requiredType instanceof WildcardBinding) {
				severity = Math.max(severity, findNullTypeAnnotationMismatch(((WildcardBinding) requiredType).bound, providedType, nullStatus));
			}
			TypeBinding requiredEnclosing = requiredType.enclosingType();
			TypeBinding providedEnclosing = providedType.enclosingType();
			if (requiredEnclosing != null && providedEnclosing != null)
				severity = Math.max(severity, findNullTypeAnnotationMismatch(requiredEnclosing, providedEnclosing, -1));
		}
	}
	return severity;
}

