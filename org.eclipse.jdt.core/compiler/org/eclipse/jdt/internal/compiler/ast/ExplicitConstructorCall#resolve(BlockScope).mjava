	public void resolve(BlockScope scope) {
		// the return type should be void for a constructor.
		// the test is made into getConstructor

		// mark the fact that we are in a constructor call.....
		// unmark at all returns
		MethodScope methodScope = scope.methodScope();
		try {
			AbstractMethodDeclaration methodDeclaration = methodScope.referenceMethod();
			if (methodDeclaration == null 
					|| !methodDeclaration.isConstructor()
					|| ((ConstructorDeclaration) methodDeclaration).constructorCall != this) {
				scope.problemReporter().invalidExplicitConstructorCall(this);
				return;
			}
			methodScope.isConstructorCall = true;
			ReferenceBinding receiverType = scope.enclosingSourceType();
			if (accessMode != This)
				receiverType = receiverType.superclass();

			if (receiverType == null) {
				return;
			}

			// qualification should be from the type of the enclosingType
			if (qualification != null) {
				if (accessMode != Super) {
					scope.problemReporter().unnecessaryEnclosingInstanceSpecification(
						qualification,
						receiverType);
				}
				ReferenceBinding enclosingType = receiverType.enclosingType();
				if (enclosingType == null) {
					scope.problemReporter().unnecessaryEnclosingInstanceSpecification(
						qualification,
						receiverType);
					discardEnclosingInstance = true;
				} else {
					TypeBinding qTb = qualification.resolveTypeExpecting(scope, enclosingType);
					qualification.implicitWidening(qTb, qTb);
				}
			}

			// arguments buffering for the method lookup
			TypeBinding[] argTypes = NoParameters;
			if (arguments != null) {
				boolean argHasError = false; // typeChecks all arguments
				int length = arguments.length;
				argTypes = new TypeBinding[length];
				for (int i = 0; i < length; i++)
					if ((argTypes[i] = arguments[i].resolveType(scope)) == null)
						argHasError = true;
				if (argHasError)
					return;
			}
			if ((binding = scope.getConstructor(receiverType, argTypes, this))
				.isValidBinding()) {
				if (isMethodUseDeprecated(binding, scope))
					scope.problemReporter().deprecatedMethod(binding, this);

				// see for user-implicit widening conversion 
				if (arguments != null) {
					int length = arguments.length;
					TypeBinding[] paramTypes = binding.parameters;
					for (int i = 0; i < length; i++)
						arguments[i].implicitWidening(paramTypes[i], argTypes[i]);
				}
				if (binding.isPrivate()) {
					binding.modifiers |= AccPrivateUsed;
				}				
			} else {
				if (binding.declaringClass == null)
					binding.declaringClass = receiverType;
				scope.problemReporter().invalidConstructor(this, binding);
			}
		} finally {
			methodScope.isConstructorCall = false;
		}
	}

