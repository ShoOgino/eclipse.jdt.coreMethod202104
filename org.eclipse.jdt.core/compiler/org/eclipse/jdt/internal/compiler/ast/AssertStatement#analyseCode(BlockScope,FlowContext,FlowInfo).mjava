	public FlowInfo analyseCode(
		BlockScope currentScope,
		FlowContext flowContext,
		FlowInfo flowInfo) {
			
		preAssertInitStateIndex = currentScope.methodScope().recordInitializationStates(flowInfo);

		Constant cst = this.assertExpression.optimizedBooleanConstant();		
		boolean isOptimizedTrueAssertion = cst != Constant.NotAConstant && cst.booleanValue() == true;
		boolean isOptimizedFalseAssertion = cst != Constant.NotAConstant && cst.booleanValue() == false;

		FlowInfo assertRawInfo = assertExpression.
			analyseCode(currentScope, flowContext, flowInfo.copy());
		UnconditionalFlowInfo assertWhenTrueInfo = assertRawInfo.initsWhenTrue().
			unconditionalInits();
		UnconditionalFlowInfo assertInfo = assertRawInfo.unconditionalCopy();
		if (isOptimizedTrueAssertion) {
			assertInfo.setReachMode(FlowInfo.UNREACHABLE);
		}
		
		if (exceptionArgument != null) {
			// only gets evaluated when escaping - results are not taken into account
			FlowInfo exceptionInfo = exceptionArgument.analyseCode(currentScope, flowContext, assertInfo.copy()); 
			
			if (!isOptimizedTrueAssertion){
				flowContext.checkExceptionHandlers(
					currentScope.getJavaLangAssertionError(),
					this,
					exceptionInfo,
					currentScope);
			}
		}
		
		if (!isOptimizedTrueAssertion){
			// add the assert support in the clinit
			manageSyntheticAccessIfNecessary(currentScope, flowInfo);
		}
		if (isOptimizedFalseAssertion) {
			return flowInfo; // if assertions are enabled, the following code will be unreachable
			// change this if we need to carry null analysis results of the assert
			// expression downstream
		} else {
			return flowInfo.mergedWith(assertInfo.nullInfoLessUnconditionalCopy()).
				addInitializationsFrom(assertWhenTrueInfo.discardInitializationInfo());
			// keep the merge from the initial code for the definite assignment 
			// analysis, tweak the null part to influence nulls downstream
		}
	}

