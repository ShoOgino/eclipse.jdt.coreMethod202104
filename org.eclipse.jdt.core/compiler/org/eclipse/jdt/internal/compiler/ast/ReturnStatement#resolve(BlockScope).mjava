	public void resolve(BlockScope scope) {
		MethodScope methodScope = scope.methodScope();
		MethodBinding methodBinding;
		TypeBinding methodType =
			(methodScope.referenceContext instanceof AbstractMethodDeclaration)
				? ((methodBinding = ((AbstractMethodDeclaration) methodScope.referenceContext).binding) == null 
					? null 
					: methodBinding.returnType)
				: VoidBinding;
		if (methodType == VoidBinding) {
			// the expression should be null
			if (expression == null)
				return;
			if ((expressionType = expression.resolveType(scope)) != null)
				scope.problemReporter().attemptToReturnNonVoidExpression(this, expressionType);
			return;
		}
		if (expression == null) {
			if (methodType != null) scope.problemReporter().shouldReturn(methodType, this);
			return;
		}
		if ((expressionType = expression.resolveType(scope)) == null)
			return;
	
		if (methodType != null && expression.isConstantValueOfTypeAssignableToType(expressionType, methodType)) {
			// dealing with constant
			expression.implicitWidening(methodType, expressionType);
			return;
		}
		if (expressionType == VoidBinding) {
			scope.problemReporter().attemptToReturnVoidValue(this);
			return;
		}
		if (methodType != null && expressionType.isCompatibleWith(methodType)) {
			expression.implicitWidening(methodType, expressionType);
			return;
		}
		if (methodType != null){
			scope.problemReporter().typeMismatchErrorActualTypeExpectedType(expression, expressionType, methodType);
		}
	}

