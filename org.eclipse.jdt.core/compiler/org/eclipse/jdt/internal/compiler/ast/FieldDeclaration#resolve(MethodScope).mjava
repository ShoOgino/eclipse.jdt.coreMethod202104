	public void resolve(MethodScope initializationScope) {

		// the two <constant = Constant.NotAConstant> could be regrouped into
		// a single line but it is clearer to have two lines while the reason of their
		// existence is not at all the same. See comment for the second one.

		//--------------------------------------------------------
		if (!this.hasBeenResolved && this.binding != null && this.binding.isValidBinding()) {

			this.hasBeenResolved = true;

			// check if field is hiding some variable - issue is that field binding already got inserted in scope
			// thus must lookup separately in super type and outer context
			ClassScope classScope = initializationScope.enclosingClassScope();
			
			if (classScope != null) {
				checkHiding: {
					SourceTypeBinding declaringType = classScope.enclosingSourceType();
					checkHidingSuperField: {
						if (declaringType.superclass == null) break checkHidingSuperField;
						Binding existingVariable = classScope.findField(declaringType.superclass, this.name, this,  false /*do not resolve hidden field*/);
						if (existingVariable == null) break checkHidingSuperField; // keep checking outer scenario
						if (!existingVariable.isValidBinding())  break checkHidingSuperField; // keep checking outer scenario
						if (existingVariable instanceof FieldBinding) {
							FieldBinding existingField = (FieldBinding) existingVariable;
							if (existingField.original() == this.binding) break checkHidingSuperField; // keep checking outer scenario
						}
						// collision with supertype field
						initializationScope.problemReporter().fieldHiding(this, existingVariable);
						break checkHiding; // already found a matching field
					}					
					// only corner case is: lookup of outer field through static declaringType, which isn't detected by #getBinding as lookup starts
					// from outer scope. Subsequent static contexts are detected for free.
					Scope outerScope = classScope.parent;
					if (outerScope.kind == Scope.COMPILATION_UNIT_SCOPE) break checkHiding;
					Binding existingVariable = outerScope.getBinding(this.name, Binding.VARIABLE, this, false /*do not resolve hidden field*/);
					if (existingVariable == null) break checkHiding;
					if (!existingVariable.isValidBinding()) break checkHiding;
					if (existingVariable == this.binding) break checkHiding;
					if (existingVariable instanceof FieldBinding) {
						FieldBinding existingField = (FieldBinding) existingVariable;
						if (existingField.original() == this.binding) break checkHiding;
						if (!existingField.isStatic() && declaringType.isStatic()) break checkHiding;
					}
					// collision with outer field or local variable
					initializationScope.problemReporter().fieldHiding(this, existingVariable);
				}
			}
			
			if (this.type != null ) { // enum constants have no declared type
				this.type.resolvedType = this.binding.type; // update binding for type reference
			}

			FieldBinding previousField = initializationScope.initializedField;
			int previousFieldID = initializationScope.lastVisibleFieldID;
			try {
				initializationScope.initializedField = this.binding;
				initializationScope.lastVisibleFieldID = this.binding.id;

				resolveAnnotations(initializationScope, this.annotations, this.binding);
				// check @Deprecated annotation presence
				if ((this.binding.getAnnotationTagBits() & TagBits.AnnotationDeprecated) == 0
						&& (this.binding.modifiers & ClassFileConstants.AccDeprecated) != 0
						&& initializationScope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5) {
					initializationScope.problemReporter().missingDeprecatedAnnotationForField(this);
				}						
				// the resolution of the initialization hasn't been done
				if (this.initialization == null) {
					this.binding.setConstant(Constant.NotAConstant);
				} else {
					// break dead-lock cycles by forcing constant to NotAConstant
					this.binding.setConstant(Constant.NotAConstant);
					
					TypeBinding fieldType = this.binding.type;
					TypeBinding initializationType;
					this.initialization.setExpectedType(fieldType); // needed in case of generic method invocation
					if (this.initialization instanceof ArrayInitializer) {

						if ((initializationType = this.initialization.resolveTypeExpecting(initializationScope, fieldType)) != null) {
							((ArrayInitializer) this.initialization).binding = (ArrayBinding) initializationType;
							this.initialization.computeConversion(initializationScope, fieldType, initializationType);
						}
					} else if ((initializationType = this.initialization.resolveType(initializationScope)) != null) {

						if (fieldType != initializationType) // must call before computeConversion() and typeMismatchError()
							initializationScope.compilationUnitScope().recordTypeConversion(fieldType, initializationType);
						if (this.initialization.isConstantValueOfTypeAssignableToType(initializationType, fieldType)
								|| (fieldType.isBaseType() && BaseTypeBinding.isWidening(fieldType.id, initializationType.id))
								|| initializationType.isCompatibleWith(fieldType)) {
							this.initialization.computeConversion(initializationScope, fieldType, initializationType);
							if (initializationType.needsUncheckedConversion(fieldType)) {
								    initializationScope.problemReporter().unsafeTypeConversion(this.initialization, initializationType, fieldType);
							}
							if (this.initialization instanceof CastExpression 
									&& (this.initialization.bits & ASTNode.UnnecessaryCast) == 0) {
								CastExpression.checkNeedForAssignedCast(initializationScope, fieldType, (CastExpression) this.initialization);
							}								
						} else if (initializationScope.isBoxingCompatibleWith(initializationType, fieldType) 
											|| (initializationType.isBaseType()  // narrowing then boxing ?
													&& initializationScope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5 // autoboxing
													&& !fieldType.isBaseType()
													&& initialization.isConstantValueOfTypeAssignableToType(initializationType, initializationScope.environment().computeBoxingType(fieldType)))) {
							this.initialization.computeConversion(initializationScope, fieldType, initializationType);
							if (this.initialization instanceof CastExpression 
									&& (this.initialization.bits & ASTNode.UnnecessaryCast) == 0) {
								CastExpression.checkNeedForAssignedCast(initializationScope, fieldType, (CastExpression) this.initialization);
							}							
						} else {
							initializationScope.problemReporter().typeMismatchError(initializationType, fieldType, this);
						}
						if (this.binding.isFinal()){ // cast from constant actual type to variable type
							this.binding.setConstant(this.initialization.constant.castTo((this.binding.type.id << 4) + this.initialization.constant.typeID()));
						}
					} else {
						this.binding.setConstant(Constant.NotAConstant);
					}
					// check for assignment with no effect
					if (this.binding == Assignment.getDirectBinding(this.initialization)) {
						initializationScope.problemReporter().assignmentHasNoEffect(this, this.name);
					}					
				}
				// Resolve Javadoc comment if one is present
				if (this.javadoc != null) {
					/*
					if (classScope != null) {
						this.javadoc.resolve(classScope);
					}
					*/
					this.javadoc.resolve(initializationScope);
				} else if (this.binding != null && this.binding.declaringClass != null && !this.binding.declaringClass.isLocalType()) {
					initializationScope.problemReporter().javadocMissing(this.sourceStart, this.sourceEnd, this.binding.modifiers);
				}
			} finally {
				initializationScope.initializedField = previousField;
				initializationScope.lastVisibleFieldID = previousFieldID;
				if (this.binding.constant() == null)
					this.binding.setConstant(Constant.NotAConstant);
			}
		}
	}

