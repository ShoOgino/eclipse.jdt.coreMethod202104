	public void resolve(BlockScope upperScope) {
		// use the scope that will hold the init declarations
		scope = new BlockScope(upperScope);
		this.elementVariable.resolve(scope); // collection expression can see itemVariable
		TypeBinding elementType = this.elementVariable.type.resolvedType;
		TypeBinding collectionType = this.collection.resolveType(scope);
		boolean hasError = elementType == null || collectionType == null;

		if (!hasError) {
			if (collectionType.isArrayType()) { // for(E e : E[])
				this.kind = ARRAY;
				this.collection.computeConversion(scope,collectionType, collectionType);
				this.collectionElementType = ((ArrayBinding) collectionType).elementsType();
				if (!collectionElementType.isCompatibleWith(elementType)
						&& !scope.isBoxingCompatibleWith(collectionElementType, elementType)) {
					scope.problemReporter().notCompatibleTypesErrorInForeach(collection, collectionElementType, elementType);
				}
				// in case we need to do a conversion
				int compileTimeTypeID = collectionElementType.id;
				if (elementType.isBaseType()) {
					if (!collectionElementType.isBaseType()) {
						compileTimeTypeID = scope.environment().computeBoxingType(collectionElementType).id;
						this.elementVariableImplicitWidening = UNBOXING;
						if (elementType.isBaseType()) {
							this.elementVariableImplicitWidening |= (elementType.id << 4) + compileTimeTypeID;
							scope.problemReporter().autoboxing(collection, collectionElementType, elementType);
						}
					} else {
						this.elementVariableImplicitWidening = (elementType.id << 4) + compileTimeTypeID;
					}
				} else {
					if (collectionElementType.isBaseType()) {
						int boxedID = scope.environment().computeBoxingType(collectionElementType).id;
						this.elementVariableImplicitWidening = BOXING | (compileTimeTypeID << 4) | compileTimeTypeID; // use primitive type in implicit conversion
						compileTimeTypeID = boxedID;
						scope.problemReporter().autoboxing(collection, collectionElementType, elementType);
					}
				}
			} else if (collectionType instanceof ReferenceBinding) {
			    ReferenceBinding iterableType = ((ReferenceBinding)collectionType).findSuperTypeErasingTo(T_JavaLangIterable, false /*Iterable is not a class*/);
			    checkIterable: {
			    	if (iterableType == null) break checkIterable;
			    	
					this.iteratorReceiverType = collectionType.erasure();
					if (((ReferenceBinding)iteratorReceiverType).findSuperTypeErasingTo(T_JavaLangIterable, false) == null) {
						this.iteratorReceiverType = iterableType; // handle indirect inheritance thru variable secondary bound
	   					this.collection.computeConversion(scope, iterableType, collectionType);
					} else {
	   					this.collection.computeConversion(scope, collectionType, collectionType);
					}

			    	TypeBinding[] arguments = null;
			    	switch (iterableType.kind()) {
			    		case Binding.RAW_TYPE : // for(Object o : Iterable)
							this.kind = RAW_ITERABLE;
							this.collectionElementType = scope.getJavaLangObject();
							if (!collectionElementType.isCompatibleWith(elementType)
									&& !scope.isBoxingCompatibleWith(collectionElementType, elementType)) {
								scope.problemReporter().notCompatibleTypesErrorInForeach(collection, collectionElementType, elementType);
							}
							// no conversion needed as only for reference types
			    			break checkIterable;
			    			
			    		case Binding.GENERIC_TYPE : // for (T t : Iterable<T>) - in case used inside Iterable itself
			    			arguments = iterableType.typeVariables();
			    			break;
			    			
			    		case Binding.PARAMETERIZED_TYPE : // for(E e : Iterable<E>)
			    			arguments = ((ParameterizedTypeBinding)iterableType).arguments;
			    			break;
			    			
			    		default:
			    			break checkIterable;
			    	}
			    	// generic or parameterized case
					if (arguments.length != 1) break checkIterable; // per construction can only be one
					this.kind = GENERIC_ITERABLE;
					
					this.collectionElementType = arguments[0]; 
					if (!collectionElementType.isCompatibleWith(elementType)
							&& !scope.isBoxingCompatibleWith(collectionElementType, elementType)) {
						scope.problemReporter().notCompatibleTypesErrorInForeach(collection, collectionElementType, elementType);
					}
					int compileTimeTypeID = collectionElementType.id;
					// no conversion needed as only for reference types
					if (elementType.isBaseType()) {
						if (!collectionElementType.isBaseType()) {
							compileTimeTypeID = scope.environment().computeBoxingType(collectionElementType).id;
							this.elementVariableImplicitWidening = UNBOXING;
							if (elementType.isBaseType()) {
								this.elementVariableImplicitWidening |= (elementType.id << 4) + compileTimeTypeID;
							}
						} else {
							this.elementVariableImplicitWidening = (elementType.id << 4) + compileTimeTypeID;
						}
					} else {
						if (collectionElementType.isBaseType()) {
							int boxedID = scope.environment().computeBoxingType(collectionElementType).id;
							this.elementVariableImplicitWidening = BOXING | (compileTimeTypeID << 4) | compileTimeTypeID; // use primitive type in implicit conversion
							compileTimeTypeID = boxedID;
						}
					}
			    }
			}
			switch(this.kind) {
				case ARRAY :
					// allocate #index secret variable (of type int)
					this.indexVariable = new LocalVariableBinding(SecretIndexVariableName, IntBinding, ClassFileConstants.AccDefault, false);
					scope.addLocalVariable(this.indexVariable);
					this.indexVariable.setConstant(NotAConstant); // not inlinable
					
					// allocate #max secret variable
					this.maxVariable = new LocalVariableBinding(SecretMaxVariableName, IntBinding, ClassFileConstants.AccDefault, false);
					scope.addLocalVariable(this.maxVariable);
					this.maxVariable.setConstant(NotAConstant); // not inlinable
					// add #array secret variable (of collection type)
					this.collectionVariable = new LocalVariableBinding(SecretCollectionVariableName, collectionType, ClassFileConstants.AccDefault, false);
					scope.addLocalVariable(this.collectionVariable);
					this.collectionVariable.setConstant(NotAConstant); // not inlinable
					break;
				case RAW_ITERABLE :
				case GENERIC_ITERABLE :
					// allocate #index secret variable (of type Iterator)
					this.indexVariable = new LocalVariableBinding(SecretIndexVariableName, scope.getJavaUtilIterator(), ClassFileConstants.AccDefault, false);
					scope.addLocalVariable(this.indexVariable);
					this.indexVariable.setConstant(NotAConstant); // not inlinable
					break;
				default :
					scope.problemReporter().invalidTypeForCollection(collection);
			}
		}
		if (action != null) {
			action.resolve(scope);
		}
	}

