	/*
	 * This retrieves the argument that maps to an enclosing instance of the suitable type,
	 * 	if not found then answers nil -- do not create one
	 *
	 *		#implicitThis		  	 					:  the implicit this will be ok
	 *		#((arg) this$n)								: available as a constructor arg
	 * 		#((arg) this$n access$m... access$p) 		: available as as a constructor arg + a sequence of synthetic accessors to synthetic fields
	 * 		#((fieldDescr) this$n access#m... access$p)	: available as a first synthetic field + a sequence of synthetic accessors to synthetic fields
	 * 		nil 		 														: not found
	 *	jls 15.9.2
	 */
	public Object[] getEmulationPath(
			ReferenceBinding targetEnclosingType, 
			boolean onlyExactMatch,
			boolean ignoreEnclosingArgInConstructorCall) {
		//TODO: (philippe) investigate why exactly test76 fails if ignoreEnclosingArgInConstructorCall is always false
		MethodScope currentMethodScope = this.methodScope();
		SourceTypeBinding sourceType = currentMethodScope.enclosingSourceType();

		// identity check
		if (!currentMethodScope.isStatic 
			&& (!currentMethodScope.isConstructorCall || ignoreEnclosingArgInConstructorCall)
			&& (sourceType == targetEnclosingType
				|| (!onlyExactMatch && targetEnclosingType.isSuperclassOf(sourceType)))) {
			if (currentMethodScope.isConstructorCall) {
				return NoEnclosingInstanceInConstructorCall;
			}
			if (currentMethodScope.isStatic){
				return NoEnclosingInstanceInStaticContext;
			}
			return EmulationPathToImplicitThis; // implicit this is good enough
		}
		if (!sourceType.isNestedType() || sourceType.isStatic()) { // no emulation from within non-inner types
			if (currentMethodScope.isConstructorCall) {
				return NoEnclosingInstanceInConstructorCall;
			}
				if (currentMethodScope.isStatic){
					return NoEnclosingInstanceInStaticContext;
				}
			return null;
		}
		boolean insideConstructor = currentMethodScope.isInsideInitializerOrConstructor();
		// use synthetic constructor arguments if possible
		if (insideConstructor) {
			SyntheticArgumentBinding syntheticArg;
			if ((syntheticArg = ((NestedTypeBinding) sourceType).getSyntheticArgument(targetEnclosingType, onlyExactMatch)) != null) {
				return new Object[] { syntheticArg };
			}
		}

		// use a direct synthetic field then
		if (currentMethodScope.isStatic) {
			return NoEnclosingInstanceInStaticContext;
		}
		FieldBinding syntheticField = sourceType.getSyntheticField(targetEnclosingType, onlyExactMatch);
		if (syntheticField != null) {
			if (currentMethodScope.isConstructorCall){
				return NoEnclosingInstanceInConstructorCall;
			}
			return new Object[] { syntheticField };
		}
		// could be reached through a sequence of enclosing instance link (nested members)
		Object[] path = new Object[2]; // probably at least 2 of them
		ReferenceBinding currentType = sourceType.enclosingType();
		if (insideConstructor) {
			path[0] = ((NestedTypeBinding) sourceType).getSyntheticArgument(currentType, onlyExactMatch);
		} else {
			if (currentMethodScope.isConstructorCall){
				return NoEnclosingInstanceInConstructorCall;
			}
			path[0] = sourceType.getSyntheticField(currentType, onlyExactMatch);
		}
		if (path[0] != null) { // keep accumulating
			
			int count = 1;
			ReferenceBinding currentEnclosingType;
			while ((currentEnclosingType = currentType.enclosingType()) != null) {

				//done?
				if (currentType == targetEnclosingType
					|| (!onlyExactMatch && targetEnclosingType.isSuperclassOf(currentType)))	break;

				if (currentMethodScope != null) {
					currentMethodScope = currentMethodScope.enclosingMethodScope();
					if (currentMethodScope != null && currentMethodScope.isConstructorCall){
						return NoEnclosingInstanceInConstructorCall;
					}
					if (currentMethodScope != null && currentMethodScope.isStatic){
						return NoEnclosingInstanceInStaticContext;
					}
				}
				
				syntheticField = ((NestedTypeBinding) currentType).getSyntheticField(currentEnclosingType, onlyExactMatch);
				if (syntheticField == null) break;

				// append inside the path
				if (count == path.length) {
					System.arraycopy(path, 0, (path = new Object[count + 1]), 0, count);
				}
				// private access emulation is necessary since synthetic field is private
				path[count++] = ((SourceTypeBinding) syntheticField.declaringClass).addSyntheticMethod(syntheticField, true);
				currentType = currentEnclosingType;
			}
			if (currentType == targetEnclosingType
				|| (!onlyExactMatch && targetEnclosingType.isSuperclassOf(currentType))) {
				return path;
			}
		}
		return null;
	}

