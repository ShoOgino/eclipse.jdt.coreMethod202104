/*
Binding creation is responsible for reporting:
	- all modifier problems (duplicates & multiple visibility modifiers + incompatible combinations)
		- plus invalid modifiers given the context... examples:
			- interface methods can only be public
			- abstract methods can only be defined by abstract classes
	- collisions... 2 methods with identical vmSelectors
	- multiple methods with the same message pattern but different return types
	- ambiguous, invisible or missing return/argument/exception types
	- check the type of any array is not void
	- check that each exception type is Throwable or a subclass of it
*/
private void computeInheritedMethods() {
	this.inheritedMethods = new HashtableOfObject(51); // maps method selectors to an array of methods... must search to match paramaters & return type
	ReferenceBinding[][] interfacesToVisit = new ReferenceBinding[3][];
	int lastPosition = -1;
	ReferenceBinding[] itsInterfaces = type.superInterfaces();
	if (itsInterfaces != NoSuperInterfaces)
		interfacesToVisit[++lastPosition] = itsInterfaces;

	ReferenceBinding superType = this.type.isClass()
		? this.type.superclass()
		: this.type.scope.getJavaLangObject(); // check interface methods against Object
	MethodBinding[] nonVisibleDefaultMethods = null;
	int nonVisibleCount = 0;

	while (superType != null) {
		if (superType.isValidBinding()) {
			if ((itsInterfaces = superType.superInterfaces()) != NoSuperInterfaces) {
				if (++lastPosition == interfacesToVisit.length)
					System.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[lastPosition * 2][], 0, lastPosition);
				interfacesToVisit[lastPosition] = itsInterfaces;
			}

			MethodBinding[] methods = superType.unResolvedMethods();
			nextMethod : for (int m = methods.length; --m >= 0;) {
				MethodBinding method = methods[m];
				if (!(method.isPrivate() || method.isConstructor() || method.isDefaultAbstract())) {
					MethodBinding[] existingMethods = (MethodBinding[]) this.inheritedMethods.get(method.selector);
					if (existingMethods != null) {
						for (int i = 0, length = existingMethods.length; i < length; i++) {
							if (areTypesEqual(method.returnType, existingMethods[i].returnType) && areParametersEqual(method, existingMethods[i])) {
								if (method.isDefault() && method.isAbstract() && method.declaringClass.fPackage != type.fPackage)
									checkPackagePrivateAbstractMethod(method);
								continue nextMethod;
							}
						}
					}
					if (nonVisibleDefaultMethods != null)
						for (int i = 0; i < nonVisibleCount; i++)
							if (CharOperation.equals(method.selector, nonVisibleDefaultMethods[i].selector)
								&& areTypesEqual(method.returnType, nonVisibleDefaultMethods[i].returnType)
								&& areParametersEqual(method, nonVisibleDefaultMethods[i])) 
									continue nextMethod;

					if (!method.isDefault() || method.declaringClass.fPackage == type.fPackage) {
						if (existingMethods == null)
							existingMethods = new MethodBinding[1];
						else
							System.arraycopy(existingMethods, 0,
								(existingMethods = new MethodBinding[existingMethods.length + 1]), 0, existingMethods.length - 1);
						existingMethods[existingMethods.length - 1] = method;
						this.inheritedMethods.put(method.selector, existingMethods);
					} else {
						if (nonVisibleDefaultMethods == null)
							nonVisibleDefaultMethods = new MethodBinding[10];
						else if (nonVisibleCount == nonVisibleDefaultMethods.length)
							System.arraycopy(nonVisibleDefaultMethods, 0,
								(nonVisibleDefaultMethods = new MethodBinding[nonVisibleCount * 2]), 0, nonVisibleCount);
						nonVisibleDefaultMethods[nonVisibleCount++] = method;

						if (method.isAbstract() && !this.type.isAbstract()) // non visible abstract methods cannot be overridden so the type must be defined abstract
							this.problemReporter().abstractMethodCannotBeOverridden(this.type, method);

						MethodBinding[] current = (MethodBinding[]) this.currentMethods.get(method.selector);
						if (current != null) { // non visible methods cannot be overridden so a warning is issued
							foundMatch : for (int i = 0, length = current.length; i < length; i++) {
								if (areTypesEqual(method.returnType, current[i].returnType) && areParametersEqual(method, current[i])) {
									this.problemReporter().overridesPackageDefaultMethod(current[i], method);
									break foundMatch;
								}
							}
						}
					}
				}
			}
			superType = superType.superclass();
		}
	}

	for (int i = 0; i <= lastPosition; i++) {
		ReferenceBinding[] interfaces = interfacesToVisit[i];
		for (int j = 0, length = interfaces.length; j < length; j++) {
			superType = interfaces[j];
			if ((superType.tagBits & InterfaceVisited) == 0) {
				superType.tagBits |= InterfaceVisited;
				if (superType.isValidBinding()) {
					if ((itsInterfaces = superType.superInterfaces()) != NoSuperInterfaces) {
						if (++lastPosition == interfacesToVisit.length)
							System.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[lastPosition * 2][], 0, lastPosition);
						interfacesToVisit[lastPosition] = itsInterfaces;
					}

					MethodBinding[] methods = superType.unResolvedMethods();
					for (int m = methods.length; --m >= 0;) { // Interface methods are all abstract public
						MethodBinding method = methods[m];
						MethodBinding[] existingMethods = (MethodBinding[]) this.inheritedMethods.get(method.selector);
						if (existingMethods == null)
							existingMethods = new MethodBinding[1];
						else
							System.arraycopy(existingMethods, 0,
								(existingMethods = new MethodBinding[existingMethods.length + 1]), 0, existingMethods.length - 1);
						existingMethods[existingMethods.length - 1] = method;
						this.inheritedMethods.put(method.selector, existingMethods);
					}
				}
			}
		}
	}

	// bit reinitialization
	for (int i = 0; i <= lastPosition; i++) {
		ReferenceBinding[] interfaces = interfacesToVisit[i];
		for (int j = 0, length = interfaces.length; j < length; j++)
			interfaces[j].tagBits &= ~InterfaceVisited;
	}
}

