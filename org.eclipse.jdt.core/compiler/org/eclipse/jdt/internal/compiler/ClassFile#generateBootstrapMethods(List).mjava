	private int generateBootstrapMethods(List functionalExpressionList) {
		/* See JVM spec 4.7.21
		   The BootstrapMethods attribute has the following format:
		   BootstrapMethods_attribute {
		      u2 attribute_name_index;
		      u4 attribute_length;
		      u2 num_bootstrap_methods;
		      {   u2 bootstrap_method_ref;
		          u2 num_bootstrap_arguments;
		          u2 bootstrap_arguments[num_bootstrap_arguments];
		      } bootstrap_methods[num_bootstrap_methods];
		 }
		*/
		// Record inner classes for MethodHandles$Lookup
		ReferenceBinding methodHandlesLookup = this.referenceBinding.scope.getJavaLangInvokeMethodHandlesLookup();
		if (methodHandlesLookup == null) return 0; // skip bootstrap section, class path problem already reported, just avoid NPE.
		recordInnerClasses(methodHandlesLookup); // Should be done, it's what javac does also
		ReferenceBinding javaLangInvokeLambdaMetafactory = this.referenceBinding.scope.getJavaLangInvokeLambdaMetafactory(); 
		int indexForMetaFactory = this.constantPool.literalIndexForMethodHandle(ClassFileConstants.MethodHandleRefKindInvokeStatic, javaLangInvokeLambdaMetafactory, 
				ConstantPool.METAFACTORY, ConstantPool.JAVA_LANG_INVOKE_LAMBDAMETAFACTORY_METAFACTORY_SIGNATURE, false);

		int numberOfBootstraps = functionalExpressionList.size();
		int localContentsOffset = this.contentsOffset;
		// Generate the boot strap attribute - since we are only making lambdas and
		// functional expressions, we know the size ahead of time - this less general
		// than the full invokedynamic scope, but fine for Java 8
		int exSize = 10 * numberOfBootstraps + 8;
		if (exSize + localContentsOffset >= this.contents.length) {
			resizeContents(exSize);
		}
		this.contentsOffset += exSize;
		
		int attributeNameIndex =
			this.constantPool.literalIndex(AttributeNamesConstants.BootstrapMethodsName);
		this.contents[localContentsOffset++] = (byte) (attributeNameIndex >> 8);
		this.contents[localContentsOffset++] = (byte) attributeNameIndex;
		int value = (numberOfBootstraps * 10) + 2;
		this.contents[localContentsOffset++] = (byte) (value >> 24);
		this.contents[localContentsOffset++] = (byte) (value >> 16);
		this.contents[localContentsOffset++] = (byte) (value >> 8);
		this.contents[localContentsOffset++] = (byte) value;
		this.contents[localContentsOffset++] = (byte) (numberOfBootstraps >> 8);
		this.contents[localContentsOffset++] = (byte) numberOfBootstraps;
		for (int i = 0; i < numberOfBootstraps; i++) {
			FunctionalExpression functional = (FunctionalExpression) functionalExpressionList.get(i);
			this.contents[localContentsOffset++] = (byte) (indexForMetaFactory >> 8);
			this.contents[localContentsOffset++] = (byte) indexForMetaFactory;
			
			this.contents[localContentsOffset++] = 0;
			this.contents[localContentsOffset++] = (byte) 3;
			
			int functionalDescriptorIndex = this.constantPool.literalIndexForMethodType(functional.descriptor.original().signature());
			this.contents[localContentsOffset++] = (byte) (functionalDescriptorIndex >> 8);
			this.contents[localContentsOffset++] = (byte) functionalDescriptorIndex;

			int methodHandleIndex = this.constantPool.literalIndexForMethodHandle(functional.binding.original()); // Speak of " implementation" (erased) version here, adaptations described below.
			this.contents[localContentsOffset++] = (byte) (methodHandleIndex >> 8);
			this.contents[localContentsOffset++] = (byte) methodHandleIndex;

			char [] instantiatedSignature = functional.descriptor.signature();
			int methodTypeIndex = this.constantPool.literalIndexForMethodType(instantiatedSignature);
			this.contents[localContentsOffset++] = (byte) (methodTypeIndex >> 8);
			this.contents[localContentsOffset++] = (byte) methodTypeIndex;
		}
		return 1;
	}

