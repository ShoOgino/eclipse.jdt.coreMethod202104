/*
 * Given the current configuration, answers which category the problem
 * falls into:
 *		Error | Warning | Ignore
 */
public int computeSeverity(int problemId){

	// severity can have been preset on the problem
//	if ((problem.severity & Fatal) != 0){
//		return Error;
//	}

	// if not then check whether it is a configurable problem
	int errorThreshold = this.options.errorThreshold;
	int warningThreshold = this.options.warningThreshold;
	
	switch(problemId){

		case IProblem.UnreachableCatch :
		case IProblem.CodeCannotBeReached :
			if ((errorThreshold & CompilerOptions.UnreachableCode) != 0){
				return Error;
			}
			if ((warningThreshold & CompilerOptions.UnreachableCode) != 0){
				return Warning;
			}
			return Ignore;

		case IProblem.MaskedCatch : 
			if ((errorThreshold & CompilerOptions.MaskedCatchBlock) != 0){
				return Error;
			}
			if ((warningThreshold & CompilerOptions.MaskedCatchBlock) != 0){
				return Warning;
			}
			return Ignore;
			
/*
		case Never Used  :
			if ((errorThreshold & ParsingOptionalError) != 0){
				return Error;
			}
			if ((warningThreshold & ParsingOptionalError) != 0){
				return Warning;
			}
			return Ignore;
*/
		case IProblem.ImportNotFound :
		case IProblem.ImportNotVisible :
		case IProblem.ImportAmbiguous :
		case IProblem.ImportInternalNameProvided :
		case IProblem.ImportInheritedNameHidesEnclosingName :
		case IProblem.DuplicateImport :
		case IProblem.ConflictingImport :
		case IProblem.CannotImportPackage :
			if ((errorThreshold & CompilerOptions.ImportProblem) != 0){
				return Error;
			}
			if ((warningThreshold & CompilerOptions.ImportProblem) != 0){
				return Warning;
			}
			return Ignore;
			
		case IProblem.UnusedImport :
			// if import problem are disabled, then ignore
			if ((errorThreshold & CompilerOptions.ImportProblem) == 0 
				&& (warningThreshold & CompilerOptions.ImportProblem) == 0){
				return Ignore;
			}
			if ((errorThreshold & CompilerOptions.UnusedImport) != 0){
				return Error;
			}
			if ((warningThreshold & CompilerOptions.UnusedImport) != 0){
				return Warning;
			}
			return Ignore;
			
		case IProblem.MethodButWithConstructorName :
			if ((errorThreshold & CompilerOptions.MethodWithConstructorName) != 0){
				return Error;
			}
			if ((warningThreshold & CompilerOptions.MethodWithConstructorName) != 0){
				return Warning;
			}
			return Ignore;
		
		case IProblem.OverridingNonVisibleMethod :
			if ((errorThreshold & CompilerOptions.OverriddenPackageDefaultMethod) != 0){
				return Error;
			}
			if ((warningThreshold & CompilerOptions.OverriddenPackageDefaultMethod) != 0){
				return Warning;
			}
			return Ignore;

		case IProblem.IncompatibleReturnTypeForNonInheritedInterfaceMethod :
		case IProblem.IncompatibleExceptionInThrowsClauseForNonInheritedInterfaceMethod :
			if ((errorThreshold & CompilerOptions.IncompatibleNonInheritedInterfaceMethod) != 0){
				return Error;
			}
			if ((warningThreshold & CompilerOptions.IncompatibleNonInheritedInterfaceMethod) != 0){
				return Warning;
			}
			return Ignore;

		case IProblem.OverridingDeprecatedMethod :				
		case IProblem.UsingDeprecatedType :				
		case IProblem.UsingDeprecatedMethod :
		case IProblem.UsingDeprecatedConstructor :
		case IProblem.UsingDeprecatedField :
			if ((errorThreshold & CompilerOptions.UsingDeprecatedAPI) != 0){
				return Error;
			}
			if ((warningThreshold & CompilerOptions.UsingDeprecatedAPI) != 0){
				return Warning;
			}
			return Ignore;
		
		case IProblem.LocalVariableIsNeverUsed :
			if ((errorThreshold & CompilerOptions.UnusedLocalVariable) != 0){
				return Error;
			}
			if ((warningThreshold & CompilerOptions.UnusedLocalVariable) != 0){
				return Warning;
			}
			return Ignore;
		
		case IProblem.ArgumentIsNeverUsed :
			if ((errorThreshold & CompilerOptions.UnusedArgument) != 0){
				return Error;
			}
			if ((warningThreshold & CompilerOptions.UnusedArgument) != 0){
				return Warning;
			}
			return Ignore;

		case IProblem.NoImplicitStringConversionForCharArrayExpression :
			if ((errorThreshold & CompilerOptions.NoImplicitStringConversion) != 0){
				return Error;
			}
			if ((warningThreshold & CompilerOptions.NoImplicitStringConversion) != 0){
				return Warning;
			}
			return Ignore;

		case IProblem.NeedToEmulateFieldReadAccess :
		case IProblem.NeedToEmulateFieldWriteAccess :
		case IProblem.NeedToEmulateMethodAccess :
		case IProblem.NeedToEmulateConstructorAccess :			
			if ((errorThreshold & CompilerOptions.AccessEmulation) != 0){
				return Error;
			}
			if ((warningThreshold & CompilerOptions.AccessEmulation) != 0){
				return Warning;
			}
			return Ignore;
		case IProblem.NonExternalizedStringLiteral :
			if ((errorThreshold & CompilerOptions.NonExternalizedString) != 0){
				return Error;
			}
			if ((warningThreshold & CompilerOptions.NonExternalizedString) != 0){
				return Warning;
			}
			return Ignore;
		case IProblem.UseAssertAsAnIdentifier :
			if ((errorThreshold & CompilerOptions.AssertUsedAsAnIdentifier) != 0){
				return Error;
			}
			if ((warningThreshold & CompilerOptions.AssertUsedAsAnIdentifier) != 0){
				return Warning;
			}
			return Ignore;		
		case IProblem.NonStaticAccessToStaticMethod :
		case IProblem.NonStaticAccessToStaticField :
			if ((errorThreshold & CompilerOptions.StaticAccessReceiver) != 0){
				return Error;
			}
			if ((warningThreshold & CompilerOptions.StaticAccessReceiver) != 0){
				return Warning;
			}
			return Ignore;		
		case IProblem.AssignmentHasNoEffect:
			if ((errorThreshold & CompilerOptions.NoEffectAssignment) != 0){
				return Error;
			}
			if ((warningThreshold & CompilerOptions.NoEffectAssignment) != 0){
				return Warning;
			}
			return Ignore;		
		case IProblem.UnusedPrivateConstructor:
		case IProblem.UnusedPrivateMethod:
		case IProblem.UnusedPrivateField:
		case IProblem.UnusedPrivateType:
			if ((errorThreshold & CompilerOptions.UnusedPrivateMember) != 0){
				return Error;
			}
			if ((warningThreshold & CompilerOptions.UnusedPrivateMember) != 0){
				return Warning;
			}
			return Ignore;		
		case IProblem.Task :
			return Warning;			
		case IProblem.LocalVariableHidingLocalVariable:
		case IProblem.LocalVariableHidingField:
		case IProblem.ArgumentHidingLocalVariable:
		case IProblem.ArgumentHidingField:
			if ((errorThreshold & CompilerOptions.LocalVariableHiding) != 0){
				return Error;
			}
			if ((warningThreshold & CompilerOptions.LocalVariableHiding) != 0){
				return Warning;
			}
			return Ignore;		
		case IProblem.FieldHidingLocalVariable:
		case IProblem.FieldHidingField:
			if ((errorThreshold & CompilerOptions.FieldHiding) != 0){
				return Error;
			}
			if ((warningThreshold & CompilerOptions.FieldHiding) != 0){
				return Warning;
			}
			return Ignore;		
		case IProblem.PossibleAccidentalBooleanAssignment:
			if ((errorThreshold & CompilerOptions.AccidentalBooleanAssign) != 0){
				return Error;
			}
			if ((warningThreshold & CompilerOptions.AccidentalBooleanAssign) != 0){
				return Warning;
			}
			return Ignore;		
		case IProblem.SuperfluousSemicolon:
			if ((errorThreshold & CompilerOptions.SuperfluousSemicolon) != 0){
				return Error;
			}
			if ((warningThreshold & CompilerOptions.SuperfluousSemicolon) != 0){
				return Warning;
			}
			return Ignore;		
		default:
			return Error;
	}
}

