/**
 * This method returns the index into the constantPool corresponding to the type descriptor.
 *
 * @param stringCharArray char[]
 * @return <CODE>int</CODE>
 */
public int literalIndexForLdc(char[] stringCharArray) {
	int index;
	if ((index = stringCache.putIfAbsent(stringCharArray, this.currentIndex)) < 0) {
		// The entry doesn't exit yet
		this.currentIndex++;
		// Write the tag first
		writeU1(StringTag);
		
		// Then the string index
		int stringIndexOffset = this.currentOffset;
		if (currentOffset + 2 >= poolContent.length) {
			resizePoolContents(2);
		}
		currentOffset+=2;

		int stringIndex;
		if ((stringIndex = UTF8Cache.putIfAbsent(stringCharArray, this.currentIndex)) < 0) {
			// The entry doesn't exit yet
			this.currentIndex++;
			// Write the tag first
			writeU1(Utf8Tag);
			// Then the size of the stringName array
			int savedCurrentOffset = currentOffset;
			if (currentOffset + 2 >= poolContent.length) {
				// we need to resize the poolContent array because we won't have
				// enough space to write the length
				resizePoolContents(2);
			}
			currentOffset += 2;
			int length = 0;
			for (int i = 0; i < stringCharArray.length; i++) {
				char current = stringCharArray[i];
				if ((current >= 0x0001) && (current <= 0x007F)) {
					// we only need one byte: ASCII table
					length++;
					if (currentOffset + 1 >= poolContent.length) {
						// we need to resize the poolContent array because we won't have
						// enough space to write the length
						resizePoolContents(1);
					}
					poolContent[currentOffset++] = (byte)(current);
				} else
					if (current > 0x07FF) {
						// we need 3 bytes
						length += 3;
						if (currentOffset + 3 >= poolContent.length) {
							// we need to resize the poolContent array because we won't have
							// enough space to write the length
							resizePoolContents(3);
						}
						poolContent[currentOffset++] = (byte) (0xE0 | ((current >> 12) & 0x0F)); // 0xE0 = 1110 0000
						poolContent[currentOffset++] = (byte) (0x80 | ((current >> 6) & 0x3F)); // 0x80 = 1000 0000
						poolContent[currentOffset++] = (byte) (0x80 | (current & 0x3F)); // 0x80 = 1000 0000
					} else {
						if (currentOffset + 2 >= poolContent.length) {
							// we need to resize the poolContent array because we won't have
							// enough space to write the length
							resizePoolContents(2);
						}
						// we can be 0 or between 0x0080 and 0x07FF
						// In that case we only need 2 bytes
						length += 2;
						poolContent[currentOffset++] = (byte) (0xC0 | ((current >> 6) & 0x1F)); // 0xC0 = 1100 0000
						poolContent[currentOffset++] = (byte) (0x80 | (current & 0x3F)); // 0x80 = 1000 0000
					}
			}
			if (length >= 65535) {
				currentOffset = savedCurrentOffset - 1;
				return 0;
			}
			// Now we know the length that we have to write in the constant pool
			// we use savedCurrentOffset to do that
			if (length > 65535) {
				return 0;
			}
			poolContent[savedCurrentOffset++] = (byte) (length >> 8);
			poolContent[savedCurrentOffset] = (byte) length;
			stringIndex = -stringIndex;
		}
		if ((index = -index) > 0xFFFF){
			this.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());
		}
		poolContent[stringIndexOffset++] = (byte) (stringIndex >> 8);
		poolContent[stringIndexOffset] = (byte) stringIndex;
	}
	return index;
}

