/*main loop of the automat
When a rule is reduced, the method consumeRule(int) is called with the number
of the consumed rule. When a terminal is consumed, the method consumeToken(int) is 
called in order to remember (when needed) the consumed token */
// (int)asr[asi(act)]
// name[symbol_index[currentKind]]
protected void parse() {
	boolean isDietParse = diet;
	int oldFirstToken = getFirstToken();
	hasError = false;
	
	hasReportedError = false;
	int act = START_STATE;
	stateStackTop = -1;
	currentToken = getFirstToken();
	ProcessTerminals : for (;;) {
		try {
			stack[++stateStackTop] = act;
		} catch (IndexOutOfBoundsException e) {
			int oldStackLength = stack.length;
			int oldStack[] = stack;
			stack = new int[oldStackLength + StackIncrement];
			System.arraycopy(oldStack, 0, stack, 0, oldStackLength);
			stack[stateStackTop] = act;
		}

		act = tAction(act, currentToken);

		if (act == ERROR_ACTION || restartRecovery) {
			int errorPos = scanner.currentPosition;
			if (!hasReportedError){
				hasError = true;
			}
			if (resumeOnSyntaxError()) {
				if (act == ERROR_ACTION) lastErrorEndPosition = errorPos;
					act = START_STATE;
					stateStackTop = -1;
					currentToken = getFirstToken();
					continue ProcessTerminals;
				} else {
					act = ERROR_ACTION;
				}	break ProcessTerminals;
			}
			if (act <= NUM_RULES)
				stateStackTop--;
			else
				if (act > ERROR_ACTION) { /* shift-reduce */
					consumeToken(currentToken);
					if (currentElement != null) this.recoveryTokenCheck();
					try{
						currentToken = scanner.getNextToken();
					} catch(InvalidInputException e){
						if (!hasReportedError){
							this.problemReporter().scannerError(this, e.getMessage());
							hasReportedError = true;
						}
						lastCheckPoint = scanner.currentPosition;
						restartRecovery = true;
					}					
					act -= ERROR_ACTION;
				} else
					if (act < ACCEPT_ACTION) { /* shift */
						consumeToken(currentToken);
						if (currentElement != null) this.recoveryTokenCheck();
						try{
							currentToken = scanner.getNextToken();
						} catch(InvalidInputException e){
							if (!hasReportedError){
								this.problemReporter().scannerError(this, e.getMessage());
								hasReportedError = true;
							}
							lastCheckPoint = scanner.currentPosition;
							restartRecovery = true;
						}					
						continue ProcessTerminals;
					} else
						break ProcessTerminals;
			
		ProcessNonTerminals : do { /* reduce */
			consumeRule(act);
			stateStackTop -= (rhs[act] - 1);
			act = ntAction(stack[stateStackTop], lhs[act]);
		} while (act <= NUM_RULES);
	}
	endParse(act);
	
	if(reportSyntaxErrorIsRequired && hasError) {
		reportSyntaxErrors(isDietParse, oldFirstToken);
	}
}

