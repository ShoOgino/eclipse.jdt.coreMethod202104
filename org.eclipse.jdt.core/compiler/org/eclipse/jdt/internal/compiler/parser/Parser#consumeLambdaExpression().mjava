protected void consumeLambdaExpression() {
	
	// LambdaExpression ::= LambdaParameters '->' LambdaBody

	this.astLengthPtr--; 	// pop length for LambdaBody (always 1)
	Statement body = (Statement) this.astStack[this.astPtr--];
	if (body instanceof Block) {
		this.nestedType--; 	// matching NestedType in "LambdaBody ::= NestedType NestedMethod  '{' BlockStatementsopt '}'"
		this.intPtr--; 		// position after '{' pushed during consumeNestedMethod()
		if (this.options.ignoreMethodBodies) {
			body = new Block(0);
		}
	}
	Argument [] arguments = null;
	int length = this.astLengthStack[this.astLengthPtr--];
	this.astPtr -= length;
	//arguments
	if (length != 0) {
		System.arraycopy(
			this.astStack,
			this.astPtr + 1,
			arguments = new Argument[length],
			0,
			length);
	}
	for (int i = 0; i < length; i++) {
		final Argument argument = arguments[i];
		if (argument.isReceiver()) {
			problemReporter().illegalThis(argument);
		}
		if (argument.name.length == 1 && argument.name[0] == '_')
			problemReporter().illegalUseOfUnderscoreAsAnIdentifier(argument.sourceStart, argument.sourceEnd, true); // true == lambdaParameter
	}
	LambdaExpression lexp = new LambdaExpression(this.compilationUnit.compilationResult, arguments, body);
	this.intPtr--;  // ')' position, discard for now.
	lexp.sourceStart = this.intStack[this.intPtr--]; // '(' position or identifier position.
	lexp.sourceEnd = body.sourceEnd;
	lexp.hasParentheses = (this.scanner.getSource()[lexp.sourceStart] == '(');
	if (body instanceof Expression) {
		Expression expression = (Expression) body;
		expression.statementEnd = body.sourceEnd;
	}
	pushOnExpressionStack(lexp);
	if (!this.parsingJava8Plus) {
		problemReporter().lambdaExpressionsNotBelow18(lexp);
	}
	this.listLength = 0; // reset this.listLength after having read all parameters
}

