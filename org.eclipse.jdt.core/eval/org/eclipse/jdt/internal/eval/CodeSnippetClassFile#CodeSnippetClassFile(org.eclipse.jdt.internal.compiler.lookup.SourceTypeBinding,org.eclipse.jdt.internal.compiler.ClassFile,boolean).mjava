/**
 * CodeSnippetClassFile constructor comment.
 * @param aType org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding
 * @param enclosingClassFile org.eclipse.jdt.internal.compiler.ClassFile
 * @param creatingProblemType boolean
 */
public CodeSnippetClassFile(
	org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding aType,
	org.eclipse.jdt.internal.compiler.ClassFile enclosingClassFile,
	boolean creatingProblemType) {
	/**
	 * INTERNAL USE-ONLY
	 * This methods creates a new instance of the receiver.
	 *
	 * @param aType org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding
	 * @param enclosingClassFile org.eclipse.jdt.internal.compiler.codegen.ClassFile
	 * @param creatingProblemType <CODE>boolean</CODE>
	 */
	referenceBinding = aType;
	header = new byte[INITIAL_HEADER_SIZE];
	// generate the magic numbers inside the header
	header[headerOffset++] = (byte) (0xCAFEBABEL >> 24);
	header[headerOffset++] = (byte) (0xCAFEBABEL >> 16);
	header[headerOffset++] = (byte) (0xCAFEBABEL >> 8);
	header[headerOffset++] = (byte) (0xCAFEBABEL >> 0);

		long targetJDK = referenceBinding.scope.environment().options.targetJDK;
		header[headerOffset++] = (byte) (targetJDK >> 8); // minor high
		header[headerOffset++] = (byte) (targetJDK >> 0); // minor low
		header[headerOffset++] = (byte) (targetJDK >> 24); // major high
		header[headerOffset++] = (byte) (targetJDK >> 16); // major low

	constantPoolOffset = headerOffset;
	headerOffset += 2;
	constantPool = new CodeSnippetConstantPool(this);
	int accessFlags = aType.getAccessFlags() | AccSuper;
	if (aType.isNestedType()) {
		if (aType.isStatic()) {
			// clear Acc_Static
			accessFlags &= ~AccStatic;
		}
		if (aType.isPrivate()) {
			// clear Acc_Private and Acc_Public
			accessFlags &= ~(AccPrivate | AccPublic);
		}
		if (aType.isProtected()) {
			// clear Acc_Protected and set Acc_Public
			accessFlags &= ~AccProtected;
			accessFlags |= AccPublic;
		}
	}
	// clear Acc_Strictfp
	accessFlags &= ~AccStrictfp;

	this.enclosingClassFile = enclosingClassFile;
	contents = new byte[INITIAL_CONTENTS_SIZE];
	// now we continue to generate the bytes inside the contents array
	contents[contentsOffset++] = (byte) (accessFlags >> 8);
	contents[contentsOffset++] = (byte) accessFlags;
	int classNameIndex = constantPool.literalIndex(aType);
	contents[contentsOffset++] = (byte) (classNameIndex >> 8);
	contents[contentsOffset++] = (byte) classNameIndex;
	int superclassNameIndex;
	if (aType.isInterface()) {
		superclassNameIndex = constantPool.literalIndexForJavaLangObject();
	} else {
		superclassNameIndex =
			(aType.superclass == null ? 0 : constantPool.literalIndex(aType.superclass));
	}
	contents[contentsOffset++] = (byte) (superclassNameIndex >> 8);
	contents[contentsOffset++] = (byte) superclassNameIndex;
	ReferenceBinding[] superInterfacesBinding = aType.superInterfaces();
	int interfacesCount = superInterfacesBinding.length;
	contents[contentsOffset++] = (byte) (interfacesCount >> 8);
	contents[contentsOffset++] = (byte) interfacesCount;
	if (superInterfacesBinding != null) {
		for (int i = 0; i < interfacesCount; i++) {
			int interfaceIndex = constantPool.literalIndex(superInterfacesBinding[i]);
			contents[contentsOffset++] = (byte) (interfaceIndex >> 8);
			contents[contentsOffset++] = (byte) interfaceIndex;
		}
	}
	produceDebugAttributes = referenceBinding.scope.environment().options.produceDebugAttributes;
	innerClassesBindings = new ReferenceBinding[INNER_CLASSES_SIZE];
	this.creatingProblemType = creatingProblemType;
	codeStream = new CodeSnippetCodeStream(this);

	// retrieve the enclosing one guaranteed to be the one matching the propagated flow info
	// 1FF9ZBU: LFCOM:ALL - Local variable attributes busted (Sanity check)
	ClassFile outermostClassFile = this.outerMostEnclosingClassFile();
	if (this == outermostClassFile) {
		codeStream.maxFieldCount = aType.scope.referenceType().maxFieldCount;
	} else {
		codeStream.maxFieldCount = outermostClassFile.codeStream.maxFieldCount;
	}
}

