	/**
	 * Splits <code>stringToSplit</code> on the top level token<br>
	 * If there are several identical token at the same level,
	 * the string is cut into many pieces.
	 * @return an object containing the operator and all the substrings
	 * or null if the string cannot be split
	 */
	public SplitLine split(String stringToSplit, int offsetInGlobalLine) {
		/*
		 * See http://dev.eclipse.org/bugs/show_bug.cgi?id=12540 and
		 * http://dev.eclipse.org/bugs/show_bug.cgi?id=14387 
		 */
		if (stringToSplit.indexOf("//$NON-NLS") != -1) { //$NON-NLS-1$
			return null;
		}
		// local variables
		int currentToken = 0;
		int splitTokenType = 0;
		int splitTokenDepth = Integer.MAX_VALUE;
		int splitTokenPriority = Integer.MAX_VALUE;

		int[] substringsStartPositions = new int[10];
		// contains the start position of substrings
		int[] substringsEndPositions = new int[10];
		// contains the start position of substrings
		int substringsCount = 1; // index in the substringsStartPosition array
		int[] splitOperators = new int[10];
		// contains the start position of substrings
		int splitOperatorsCount = 0; // index in the substringsStartPosition array
		int[] openParenthesisPosition = new int[10];
		int openParenthesisPositionCount = 0;
		int position = 0;
		int lastOpenParenthesisPosition = -1;
		// used to remember the position of the 1st open parenthesis
		// needed for a pattern like: A.B(C); we want formatted like A.B( split C);
		// setup the scanner with a new source
		int lastCommentStartPosition = -1;
		// to remember the start position of the last comment
		int firstTokenOnLine = -1;
		// to remember the first token of the line
		int previousToken = -1;
		// to remember the previous token.
		splitScanner.setSource(stringToSplit.toCharArray());

		try {
			// start the loop
			while (true) {
				// takes the next token
				try {
					if (currentToken != TerminalTokens.TokenNameWHITESPACE)
						previousToken = currentToken;
					currentToken = splitScanner.getNextToken();
				} catch (InvalidInputException e) {
					if (!handleInvalidToken(e))
						throw e;
					currentToken = 0; // this value is not modify when an exception is raised.
				}
				if (currentToken == TokenNameEOF)
					break;

				if (firstTokenOnLine == -1) {
					firstTokenOnLine = currentToken;
				}
				switch (currentToken) {
					case TokenNameRBRACE :
					case TokenNameRPAREN :
						if (openParenthesisPositionCount > 0) {
							if (openParenthesisPositionCount == 1
								&& lastOpenParenthesisPosition < openParenthesisPosition[0]) {
								lastOpenParenthesisPosition = openParenthesisPosition[0];
							} else if (
								(splitTokenDepth == Integer.MAX_VALUE)
									|| (splitTokenDepth > openParenthesisPositionCount
										&& openParenthesisPositionCount == 1)) {
								splitTokenType = 0;
								splitTokenDepth = openParenthesisPositionCount;
								splitTokenPriority = Integer.MAX_VALUE;
								substringsStartPositions[0] = 0;
								// better token means the whole line until now is the first substring
								substringsCount = 1; // resets the count of substrings
								substringsEndPositions[0] = openParenthesisPosition[0];
								// substring ends on operator start
								position = openParenthesisPosition[0];
								// the string mustn't be cut before the closing parenthesis but after the opening one.
								splitOperatorsCount = 1; // resets the count of split operators
								splitOperators[0] = 0;
							}
							openParenthesisPositionCount--;
						}
						break;
					case TokenNameLBRACE :
					case TokenNameLPAREN :
						if (openParenthesisPositionCount == openParenthesisPosition.length) {
							System.arraycopy(
								openParenthesisPosition,
								0,
								(openParenthesisPosition = new int[openParenthesisPositionCount * 2]),
								0,
								openParenthesisPositionCount);
						}
						openParenthesisPosition[openParenthesisPositionCount++] =
							splitScanner.currentPosition;
						if (currentToken == TokenNameLPAREN && previousToken == TokenNameRPAREN) {
							openParenthesisPosition[openParenthesisPositionCount - 1] =
								splitScanner.startPosition;
						}
						break;
					case TokenNameSEMICOLON : // ;
					case TokenNameCOMMA : // ,
					case TokenNameEQUAL : // =
						if (openParenthesisPositionCount < splitTokenDepth
							|| (openParenthesisPositionCount == splitTokenDepth
								&& splitTokenPriority > getTokenPriority(currentToken))) {
							// the current token is better than the one we currently have
							// (in level or in priority if same level)
							// reset the substringsCount
							splitTokenDepth = openParenthesisPositionCount;
							splitTokenType = currentToken;
							splitTokenPriority = getTokenPriority(currentToken);
							substringsStartPositions[0] = 0;
							// better token means the whole line until now is the first substring

							if (separateFirstArgumentOn(firstTokenOnLine)
								&& openParenthesisPositionCount > 0) {
								substringsCount = 2; // resets the count of substrings

								substringsEndPositions[0] = openParenthesisPosition[splitTokenDepth - 1];
								substringsStartPositions[1] = openParenthesisPosition[splitTokenDepth - 1];
								substringsEndPositions[1] = splitScanner.startPosition;
								splitOperatorsCount = 2; // resets the count of split operators
								splitOperators[0] = 0;
								splitOperators[1] = currentToken;
								position = splitScanner.currentPosition;
								// next substring will start from operator end
							} else {
								substringsCount = 1; // resets the count of substrings

								substringsEndPositions[0] = splitScanner.startPosition;
								// substring ends on operator start
								position = splitScanner.currentPosition;
								// next substring will start from operator end
								splitOperatorsCount = 1; // resets the count of split operators
								splitOperators[0] = currentToken;
							}
						} else {
							if ((openParenthesisPositionCount == splitTokenDepth
								&& splitTokenPriority == getTokenPriority(currentToken))
								&& splitTokenType != TokenNameEQUAL
								&& currentToken != TokenNameEQUAL) {
								// fix for 1FG0BCN: LFCOM:WIN98 - Missing one indentation after split
								// take only the 1st = into account.
								// if another token with the same priority is found,
								// push the start position of the substring and
								// push the token into the stack.
								// create a new array object if the current one is full.
								if (substringsCount == substringsStartPositions.length) {
									System.arraycopy(
										substringsStartPositions,
										0,
										(substringsStartPositions = new int[substringsCount * 2]),
										0,
										substringsCount);
									System.arraycopy(
										substringsEndPositions,
										0,
										(substringsEndPositions = new int[substringsCount * 2]),
										0,
										substringsCount);
								}
								if (splitOperatorsCount == splitOperators.length) {
									System.arraycopy(
										splitOperators,
										0,
										(splitOperators = new int[splitOperatorsCount * 2]),
										0,
										splitOperatorsCount);
								}
								substringsStartPositions[substringsCount] = position;
								substringsEndPositions[substringsCount++] = splitScanner.startPosition;
								// substring ends on operator start
								position = splitScanner.currentPosition;
								// next substring will start from operator end
								splitOperators[splitOperatorsCount++] = currentToken;
							}
						}
						break;

					case TokenNameCOLON : // : (15.24)
						// see 1FK7C5R, we only split on a colon, when it is associated with a question-mark.
						// indeed it might appear also behind a case statement, and we do not to break at this point.
						if ((splitOperatorsCount == 0)
							|| splitOperators[splitOperatorsCount - 1] != TokenNameQUESTION) {
							break;
						}
					case TokenNameextends :
					case TokenNameimplements :
					case TokenNamethrows :

					case TokenNameDOT : // .
					case TokenNameMULTIPLY : // * (15.16.1)
					case TokenNameDIVIDE : // / (15.16.2)
					case TokenNameREMAINDER : // % (15.16.3)
					case TokenNamePLUS : // + (15.17, 15.17.2)
					case TokenNameMINUS : // - (15.17.2)
					case TokenNameLEFT_SHIFT : // << (15.18)
					case TokenNameRIGHT_SHIFT : // >> (15.18)
					case TokenNameUNSIGNED_RIGHT_SHIFT : // >>> (15.18)
					case TokenNameLESS : // < (15.19.1)
					case TokenNameLESS_EQUAL : // <= (15.19.1)
					case TokenNameGREATER : // > (15.19.1)
					case TokenNameGREATER_EQUAL : // >= (15.19.1)
					case TokenNameinstanceof : // instanceof
					case TokenNameEQUAL_EQUAL : // == (15.20, 15.20.1, 15.20.2, 15.20.3)
					case TokenNameNOT_EQUAL : // != (15.20, 15.20.1, 15.20.2, 15.20.3)
					case TokenNameAND : // & (15.21, 15.21.1, 15.21.2)
					case TokenNameOR : // | (15.21, 15.21.1, 15.21.2)
					case TokenNameXOR : // ^ (15.21, 15.21.1, 15.21.2)
					case TokenNameAND_AND : // && (15.22)
					case TokenNameOR_OR : // || (15.23)
					case TokenNameQUESTION : // ? (15.24)
					case TokenNameMULTIPLY_EQUAL : // *= (15.25.2)
					case TokenNameDIVIDE_EQUAL : // /= (15.25.2)
					case TokenNameREMAINDER_EQUAL : // %= (15.25.2)
					case TokenNamePLUS_EQUAL : // += (15.25.2)
					case TokenNameMINUS_EQUAL : // -= (15.25.2)
					case TokenNameLEFT_SHIFT_EQUAL : // <<= (15.25.2)
					case TokenNameRIGHT_SHIFT_EQUAL : // >>= (15.25.2)
					case TokenNameUNSIGNED_RIGHT_SHIFT_EQUAL : // >>>= (15.25.2)
					case TokenNameAND_EQUAL : // &= (15.25.2)
					case TokenNameXOR_EQUAL : // ^= (15.25.2)
					case TokenNameOR_EQUAL : // |= (15.25.2)

						if ((openParenthesisPositionCount < splitTokenDepth
							|| (openParenthesisPositionCount == splitTokenDepth
								&& splitTokenPriority > getTokenPriority(currentToken)))
							&& !((currentToken == TokenNamePLUS || currentToken == TokenNameMINUS)
								&& (previousToken == TokenNameLBRACE
									|| previousToken == TokenNameLBRACKET
									|| splitScanner.startPosition == 0))) {
							// the current token is better than the one we currently have
							// (in level or in priority if same level)
							// reset the substringsCount
							splitTokenDepth = openParenthesisPositionCount;
							splitTokenType = currentToken;
							splitTokenPriority = getTokenPriority(currentToken);
							substringsStartPositions[0] = 0;
							// better token means the whole line until now is the first substring

							if (separateFirstArgumentOn(firstTokenOnLine)
								&& openParenthesisPositionCount > 0) {
								substringsCount = 2; // resets the count of substrings

								substringsEndPositions[0] = openParenthesisPosition[splitTokenDepth - 1];
								substringsStartPositions[1] = openParenthesisPosition[splitTokenDepth - 1];
								substringsEndPositions[1] = splitScanner.startPosition;
								splitOperatorsCount = 3; // resets the count of split operators
								splitOperators[0] = 0;
								splitOperators[1] = 0;
								splitOperators[2] = currentToken;
								position = splitScanner.currentPosition;
								// next substring will start from operator end
							} else {
								substringsCount = 1; // resets the count of substrings

								substringsEndPositions[0] = splitScanner.startPosition;
								// substring ends on operator start
								position = splitScanner.currentPosition;
								// next substring will start from operator end
								splitOperatorsCount = 2; // resets the count of split operators
								splitOperators[0] = 0;
								// nothing for first operand since operator will be inserted in front of the second operand
								splitOperators[1] = currentToken;

							}
						} else {
							if (openParenthesisPositionCount == splitTokenDepth
								&& splitTokenPriority == getTokenPriority(currentToken)) {
								// if another token with the same priority is found,
								// push the start position of the substring and
								// push the token into the stack.
								// create a new array object if the current one is full.
								if (substringsCount == substringsStartPositions.length) {
									System.arraycopy(
										substringsStartPositions,
										0,
										(substringsStartPositions = new int[substringsCount * 2]),
										0,
										substringsCount);
									System.arraycopy(
										substringsEndPositions,
										0,
										(substringsEndPositions = new int[substringsCount * 2]),
										0,
										substringsCount);
								}
								if (splitOperatorsCount == splitOperators.length) {
									System.arraycopy(
										splitOperators,
										0,
										(splitOperators = new int[splitOperatorsCount * 2]),
										0,
										splitOperatorsCount);
								}
								substringsStartPositions[substringsCount] = position;
								substringsEndPositions[substringsCount++] = splitScanner.startPosition;
								// substring ends on operator start
								position = splitScanner.currentPosition;
								// next substring will start from operator end
								splitOperators[splitOperatorsCount++] = currentToken;
							}
						}
					default :
						break;
				}
				if (isComment(currentToken)) {
					lastCommentStartPosition = splitScanner.startPosition;
				} else {
					lastCommentStartPosition = -1;
				}
			}
		} catch (InvalidInputException e) {
			return null;
		}
		// if the string cannot be split, return null.
		if (splitOperatorsCount == 0)
			return null;

		// ## SPECIAL CASES BEGIN
		if (((splitOperatorsCount == 2
			&& splitOperators[1] == TokenNameDOT
			&& splitTokenDepth == 0
			&& lastOpenParenthesisPosition > -1)
			|| (splitOperatorsCount > 2
				&& splitOperators[1] == TokenNameDOT
				&& splitTokenDepth == 0
				&& lastOpenParenthesisPosition > -1
				&& lastOpenParenthesisPosition <= options.maxLineLength)
			|| (separateFirstArgumentOn(firstTokenOnLine)
				&& splitTokenDepth > 0
				&& lastOpenParenthesisPosition > -1))
			&& (lastOpenParenthesisPosition < splitScanner.source.length
				&& splitScanner.source[lastOpenParenthesisPosition] != ')')) {
			// fix for 1FH4J2H: LFCOM:WINNT - Formatter - Empty parenthesis should not be broken on two lines
			// only one split on a top level .
			// or more than one split on . and substring before open parenthesis fits one line.
			// or split inside parenthesis and first token is not a for/while/if
			SplitLine sl =
				split(
					stringToSplit.substring(lastOpenParenthesisPosition),
					lastOpenParenthesisPosition);
			if (sl == null || sl.operators[0] != TokenNameCOMMA) {
				// trim() is used to remove the extra blanks at the end of the substring. See PR 1FGYPI1
				return new SplitLine(
					new int[] { 0, 0 },
					new String[] {
						stringToSplit.substring(0, lastOpenParenthesisPosition).trim(),
						stringToSplit.substring(lastOpenParenthesisPosition)},
					new int[] {
						offsetInGlobalLine,
						lastOpenParenthesisPosition + offsetInGlobalLine });
			} else {
				// right substring can be split and is split on comma
				// copy substrings and operators
				// except if the 1st string is empty.
				int startIndex = (sl.substrings[0].length() == 0) ? 1 : 0;
				int subStringsLength = sl.substrings.length + 1 - startIndex;
				String[] result = new String[subStringsLength];
				int[] startIndexes = new int[subStringsLength];
				int operatorsLength = sl.operators.length + 1 - startIndex;
				int[] operators = new int[operatorsLength];

				result[0] = stringToSplit.substring(0, lastOpenParenthesisPosition);
				operators[0] = 0;

				System.arraycopy(
					sl.startSubstringsIndexes,
					startIndex,
					startIndexes,
					1,
					subStringsLength - 1);
				for (int i = subStringsLength - 1; i >= 0; i--) {
					startIndexes[i] += offsetInGlobalLine;
				}
				System.arraycopy(sl.substrings, startIndex, result, 1, subStringsLength - 1);
				System.arraycopy(sl.operators, startIndex, operators, 1, operatorsLength - 1);

				return new SplitLine(operators, result, startIndexes);
			}
		}
		// if the last token is a comment and the substring before the comment fits on a line,
		// split before the comment and return the result.
		if (lastCommentStartPosition > -1
			&& lastCommentStartPosition < options.maxLineLength
			&& splitTokenPriority > 50) {
			int end = lastCommentStartPosition;
			int start = lastCommentStartPosition;
			if (stringToSplit.charAt(end - 1) == ' ') {
				end--;
			}
			if (start != end && stringToSplit.charAt(start) == ' ') {
				start++;
			}
			return new SplitLine(
				new int[] { 0, 0 },
				new String[] { stringToSplit.substring(0, end), stringToSplit.substring(start)},
				new int[] { 0, start });
		}
		if (position != stringToSplit.length()) {
			if (substringsCount == substringsStartPositions.length) {
				System.arraycopy(
					substringsStartPositions,
					0,
					(substringsStartPositions = new int[substringsCount * 2]),
					0,
					substringsCount);
				System.arraycopy(
					substringsEndPositions,
					0,
					(substringsEndPositions = new int[substringsCount * 2]),
					0,
					substringsCount);
			}
			// avoid empty extra substring, e.g. line terminated with a semi-colon
			substringsStartPositions[substringsCount] = position;
			substringsEndPositions[substringsCount++] = stringToSplit.length();
		}
		if (splitOperatorsCount == splitOperators.length) {
			System.arraycopy(
				splitOperators,
				0,
				(splitOperators = new int[splitOperatorsCount * 2]),
				0,
				splitOperatorsCount);
		}
		splitOperators[splitOperatorsCount] = 0;

		// the last element of the stack is the position of the end of StringToSPlit
		// +1 because the substring method excludes the last character
		String[] result = new String[substringsCount];
		for (int i = 0; i < substringsCount; i++) {
			int start = substringsStartPositions[i];
			int end = substringsEndPositions[i];
			if (stringToSplit.charAt(start) == ' ') {
				start++;
				substringsStartPositions[i]++;
			}
			if (end != start && stringToSplit.charAt(end - 1) == ' ') {
				end--;
			}
			result[i] = stringToSplit.substring(start, end);
			substringsStartPositions[i] += offsetInGlobalLine;
		}
		if (splitOperatorsCount > substringsCount) {
			System.arraycopy(
				substringsStartPositions,
				0,
				(substringsStartPositions = new int[splitOperatorsCount]),
				0,
				substringsCount);
			System.arraycopy(
				substringsEndPositions,
				0,
				(substringsEndPositions = new int[splitOperatorsCount]),
				0,
				substringsCount);
			for (int i = substringsCount; i < splitOperatorsCount; i++) {
				substringsStartPositions[i] = position;
				substringsEndPositions[i] = position;
			}
			System.arraycopy(
				splitOperators,
				0,
				(splitOperators = new int[splitOperatorsCount]),
				0,
				splitOperatorsCount);
		} else {
			System.arraycopy(
				substringsStartPositions,
				0,
				(substringsStartPositions = new int[substringsCount]),
				0,
				substringsCount);
			System.arraycopy(
				substringsEndPositions,
				0,
				(substringsEndPositions = new int[substringsCount]),
				0,
				substringsCount);
			System.arraycopy(
				splitOperators,
				0,
				(splitOperators = new int[substringsCount]),
				0,
				substringsCount);
		}
		SplitLine splitLine =
			new SplitLine(splitOperators, result, substringsStartPositions);
		return splitLine;
	}

