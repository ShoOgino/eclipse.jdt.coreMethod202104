	private void formatMessageSend(
		MessageSend messageSend,
		BlockScope scope,
		Alignment messageAlignment) {

		if (messageAlignment != null) {
			if (!this.preferences.wrap_outer_expressions_when_nested || messageAlignment.canAlign()) {
				this.scribe.alignFragment(messageAlignment, 0);
			}
			this.scribe.printNextToken(TerminalTokens.TokenNameDOT);
		}
		TypeReference[] typeArguments = messageSend.typeArguments;
		if (typeArguments != null) {
				this.scribe.printNextToken(TerminalTokens.TokenNameLESS, this.preferences.insert_space_before_opening_angle_bracket_in_type_arguments);
				if (this.preferences.insert_space_after_opening_angle_bracket_in_type_arguments) {
					this.scribe.space();
				}
				int length = typeArguments.length;
				for (int i = 0; i < length - 1; i++) {
					typeArguments[i].traverse(this, scope);
					this.scribe.printNextToken(TerminalTokens.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_type_arguments);
					if (this.preferences.insert_space_after_comma_in_type_arguments) {
						this.scribe.space();
					}
				}
				typeArguments[length - 1].traverse(this, scope);
				if (isClosingGenericToken()) {
					this.scribe.printNextToken(CLOSING_GENERICS_EXPECTEDTOKENS, this.preferences.insert_space_before_closing_angle_bracket_in_type_arguments);
				}
				if (this.preferences.insert_space_after_closing_angle_bracket_in_type_arguments) {
					this.scribe.space();
				}
		}
		this.scribe.printNextToken(TerminalTokens.TokenNameIdentifier); // selector
		this.scribe.printNextToken(TerminalTokens.TokenNameLPAREN, this.preferences.insert_space_before_opening_paren_in_method_invocation);

		final Expression[] arguments = messageSend.arguments;
		if (arguments != null) {
			if (this.preferences.insert_space_after_opening_paren_in_method_invocation) {
				this.scribe.space();
			}
			int argumentsLength = arguments.length;
			if (argumentsLength > 1) {
				int alignmentMode = this.preferences.alignment_for_arguments_in_method_invocation;
				Alignment argumentsAlignment = this.scribe.createAlignment(
						Alignment.MESSAGE_ARGUMENTS,
						alignmentMode,
						argumentsLength,
						this.scribe.scanner.currentPosition);
				this.scribe.enterAlignment(argumentsAlignment);
				boolean ok = false;
				do {
					switch (alignmentMode & Alignment.SPLIT_MASK) {
						case Alignment.M_COMPACT_SPLIT:
						case Alignment.M_NEXT_PER_LINE_SPLIT:
							argumentsAlignment.startingColumn = this.scribe.column;
							break;
					}
					try {
						for (int i = 0; i < argumentsLength; i++) {
							if (i > 0) {
								this.scribe.printNextToken(TerminalTokens.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_method_invocation_arguments);
								this.scribe.printComment(CodeFormatter.K_UNKNOWN, Scribe.BASIC_TRAILING_COMMENT);
								if (this.scribe.lastNumberOfNewLines == 1) {
									// a new line has been inserted while printing the comment
									// hence we need to use the break indentation level before printing next token...
									this.scribe.indentationLevel = argumentsAlignment.breakIndentationLevel;
								}
							}
							this.scribe.alignFragment(argumentsAlignment, i);
							if (i > 0 && this.preferences.insert_space_after_comma_in_method_invocation_arguments) {
								this.scribe.space();
							}
							int fragmentIndentation = 0;
							if (i == 0) {
								int wrappedIndex = argumentsAlignment.wrappedIndex();
								if (wrappedIndex >= 0) {
									fragmentIndentation = argumentsAlignment.fragmentIndentations[wrappedIndex];
									if ((argumentsAlignment.mode & Alignment.M_INDENT_ON_COLUMN) != 0 && fragmentIndentation > 0) {
										this.scribe.indentationLevel = fragmentIndentation;
									}
								}
							}
							arguments[i].traverse(this, scope);
							argumentsAlignment.startingColumn = -1;
						}
						ok = true;
					} catch (AlignmentException e) {
						this.scribe.redoAlignment(e);
					}
				} while (!ok);
				this.scribe.exitAlignment(argumentsAlignment, true);
			} else {
				arguments[0].traverse(this, scope);
			}
			this.scribe.printNextToken(TerminalTokens.TokenNameRPAREN, this.preferences.insert_space_before_closing_paren_in_method_invocation);
		} else {
			this.scribe.printNextToken(TerminalTokens.TokenNameRPAREN, this.preferences.insert_space_between_empty_parens_in_method_invocation);
		}
	}

