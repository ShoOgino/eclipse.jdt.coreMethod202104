	/** 
	 * Formats the input string.
	 */
	private void format() {
		reset();
		
		int token = 0;
		int previousToken = 0;
		int previousCompilableToken = 0;
		int indentationOffset = 0;
		int newLinesInWhitespace = 0;

		// number of new lines in the previous whitespace token
		// (used to leave blank lines before comments)
		int pendingNewLines = 0;
		boolean expectingOpenBrace = false;
		boolean clearNonBlockIndents = false;
		// true if all indentations till the 1st { (usefull after } or ;)
		boolean pendingSpace = true;
		boolean pendingNewlineAfterParen = false;
		// true when a cr is to be put after a ) (in conditional statements)
		boolean inAssignment = false;
		boolean inArrayAssignment = false;
		boolean inThrowsClause = false;
		boolean inClassOrInterfaceHeader = false;

		// openBracketCount is used to count the number of open brackets not closed yet.
		int openBracketCount = 0;
		int unarySignModifier = 0;

		// openParenthesis[0] is used to count the parenthesis not belonging to a condition
		// (eg foo();). parenthesis in for (...) are count elsewhere in the array.
		int openParenthesisCount = 1;
		int[] openParenthesis = new int[10];

		// tokenBeforeColon is used to know what token goes along with the current :
		// it can be case or ?
		int tokenBeforeColonCount = 0;
		int[] tokenBeforeColon = new int[10];

		constructionsCount = 0; // initializes the constructions count.

		// contains DO if in a DO..WHILE statement, UNITIALIZED otherwise.
		int nlicsToken = 0;

		// fix for 1FF17XY: LFCOM:ALL - Format problem on not matching } and else 
		boolean specialElse = false;

		// OPTION (IndentationLevel): initial indentation level may be non-zero.
		currentLineIndentationLevel += constructionsCount;

		// An InvalidInputException exception might cause the termination of this loop.
		try {
			while (true) {
				// Get the next token.  Catch invalid input and output it
				// with minimal formatting, also catch end of input and
				// exit the loop.
				try {
					token = scanner.getNextToken();
					
					// Patch for line comment
					// See PR http://dev.eclipse.org/bugs/show_bug.cgi?id=23096
					if (token == TerminalTokens.TokenNameCOMMENT_LINE) {
						int length = scanner.currentPosition;
						loop: for (int index = length - 1; index >= 0; index--) {
							switch(scanner.source[index]) {
								case '\r' :
								case '\n' :
									scanner.currentPosition--;
									break;
								default:
									break loop;
							}
						}
					}
				} catch (InvalidInputException e) {
					if (!handleInvalidToken(e)) {
						throw e;
					}
					token = 0;
				}
				if (token == TerminalTokens.TokenNameEOF)
					break;

				/* ## MODIFYING the indentation level before generating new lines
				and indentation in the output string
				*/

				// Removes all the indentations made by statements not followed by a block
				// except if the current token is ELSE, CATCH or if we are in a switch/case
				if (clearNonBlockIndents && (token != TerminalTokens.TokenNameWHITESPACE)) {
					switch (token) {
						case TokenNameelse :
							if (constructionsCount > 0
								&& constructions[constructionsCount - 1] == TokenNameelse) {
								pendingNewLines = 1;
								specialElse = true;
							}
							indentationLevel += popInclusiveUntil(TokenNameif);
							break;
						case TokenNamecatch :
							indentationLevel += popInclusiveUntil(TokenNamecatch);
							break;
						case TokenNamefinally :
							indentationLevel += popInclusiveUntil(TokenNamecatch);
							break;
						case TokenNamewhile :
							if (nlicsToken == TokenNamedo) {
								indentationLevel += pop(TokenNamedo);
								break;
							}
						default :
							indentationLevel += popExclusiveUntilBlockOrCase();
							// clear until a CASE, DEFAULT or BLOCK is encountered.
							// Thus, the indentationLevel is correctly cleared either
							// in a switch/case statement or in any other situation.
					}
					clearNonBlockIndents = false;
				}
				// returns to the indentation level created by the SWITCH keyword
				// if the current token is a CASE or a DEFAULT
				if (token == TokenNamecase || token == TokenNamedefault) {
					indentationLevel += pop(TokenNamecase);
				}
				if (token == TerminalTokens.TokenNamethrows) {
					inThrowsClause = true;
				}
				if ((token == TerminalTokens.TokenNameclass || token == TerminalTokens.TokenNameinterface) && previousToken != TerminalTokens.TokenNameDOT) {
					inClassOrInterfaceHeader = true;
				}

				/* ## APPEND newlines and indentations to the output string
				*/
				// Do not add a new line between ELSE and IF, if the option elseIfOnSameLine is true.
				// Fix for 1ETLWPZ: IVJCOM:ALL - incorrect "else if" formatting
				if (pendingNewlineAfterParen
					&& previousCompilableToken == TokenNameelse
					&& token == TokenNameif
					&& options.compactElseIfMode) {
					pendingNewlineAfterParen = false;
					pendingNewLines = 0;
					indentationLevel += pop(TokenNameelse);
					// because else if is now one single statement,
					// the indentation level after it is increased by one and not by 2
					// (else = 1 indent, if = 1 indent, but else if = 1 indent, not 2).
				}
				// Add a newline & indent to the formatted source string if
				// a for/if-else/while statement was scanned and there is no block
				// following it.
				pendingNewlineAfterParen =
					pendingNewlineAfterParen
						|| (previousCompilableToken == TokenNameRPAREN && token == TokenNameLBRACE);
				if (pendingNewlineAfterParen && token != TerminalTokens.TokenNameWHITESPACE) {
					pendingNewlineAfterParen = false;

					// Do to add a newline & indent sequence if the current token is an
					// open brace or a period or if the current token is a semi-colon and the
					// previous token is a close paren.
					// add a new line if a parenthesis belonging to a for() statement
					// has been closed and the current token is not an opening brace
					if (token != TokenNameLBRACE
						&& !isComment(token) // to avoid adding new line between else and a comment
						&& token != TokenNameDOT
						&& !(previousCompilableToken == TokenNameRPAREN && token == TokenNameSEMICOLON)) {
						newLine(1);
						currentLineIndentationLevel = indentationLevel;
						pendingNewLines = 0;
						pendingSpace = false;
					} else {
						if (token == TokenNameLBRACE && options.newLineBeforeOpeningBraceMode) {
							newLine(1);
							if (constructionsCount > 0
								&& constructions[constructionsCount - 1] != BLOCK
								&& constructions[constructionsCount - 1] != NONINDENT_BLOCK) {
								currentLineIndentationLevel = indentationLevel - 1;
							} else {
								currentLineIndentationLevel = indentationLevel;
							}
							pendingNewLines = 0;
							pendingSpace = false;
						}
					}
				}
				if (token == TokenNameLBRACE
					&& options.newLineBeforeOpeningBraceMode
					&& constructionsCount > 0
					&& constructions[constructionsCount - 1] == TokenNamedo) {
					newLine(1);
					currentLineIndentationLevel = indentationLevel - 1;
					pendingNewLines = 0;
					pendingSpace = false;
				}
				// see PR 1G5G8EC
				if (token == TokenNameLBRACE && inThrowsClause) {
					inThrowsClause = false;
					if (options.newLineBeforeOpeningBraceMode) {
						newLine(1);
						currentLineIndentationLevel = indentationLevel;
						pendingNewLines = 0;
						pendingSpace = false;
					}
				}
				// see PR 1G5G82G
				if (token == TokenNameLBRACE && inClassOrInterfaceHeader) {
					inClassOrInterfaceHeader = false;
					if (options.newLineBeforeOpeningBraceMode) {
						newLine(1);
						currentLineIndentationLevel = indentationLevel;
						pendingNewLines = 0;
						pendingSpace = false;
					}
				}
				// Add pending new lines to the formatted source string.
				// Note: pending new lines are not added if the current token
				// is a single line comment or whitespace.
				// if the comment is between parenthesis, there is no blank line preservation
				// (if it's a one-line comment, a blank line is added after it).
				if (((pendingNewLines > 0 && (!isComment(token)))
					|| (newLinesInWhitespace > 0 && (openParenthesisCount <= 1 && isComment(token)))
					|| (previousCompilableToken == TokenNameLBRACE && token == TokenNameRBRACE))
					&& token != TerminalTokens.TokenNameWHITESPACE) {

					// Do not add newline & indent between an adjoining close brace and
					// close paren.  Anonymous inner classes may use this form.
					boolean closeBraceAndCloseParen =
						previousToken == TokenNameRBRACE && token == TokenNameRPAREN;

					// OPTION (NewLineInCompoundStatement): do not add newline & indent
					// between close brace and else, (do) while, catch, and finally if
					// newlineInCompoundStatement is true.
					boolean nlicsOption =
						previousToken == TokenNameRBRACE
							&& !options.newlineInControlStatementMode
							&& (token == TokenNameelse
								|| (token == TokenNamewhile && nlicsToken == TokenNamedo)
								|| token == TokenNamecatch
								|| token == TokenNamefinally);

					// Do not add a newline & indent between a close brace and semi-colon.
					boolean semiColonAndCloseBrace =
						previousToken == TokenNameRBRACE && token == TokenNameSEMICOLON;

					// Do not add a new line & indent between a multiline comment and a opening brace
					boolean commentAndOpenBrace =
						previousToken == TerminalTokens.TokenNameCOMMENT_BLOCK && token == TokenNameLBRACE;

					// Do not add a newline & indent between a close brace and a colon (in array assignments, for example).
					boolean commaAndCloseBrace =
						previousToken == TokenNameRBRACE && token == TokenNameCOMMA;

					// Add a newline and indent, if appropriate.
					if (specialElse
						|| (!commentAndOpenBrace
							&& !closeBraceAndCloseParen
							&& !nlicsOption
							&& !semiColonAndCloseBrace
							&& !commaAndCloseBrace)) {

						// if clearAllBlankLinesMode=false, leaves the blank lines
						// inserted by the user
						// if clearAllBlankLinesMode=true, removes all of then
						// and insert only blank lines required by the formatting.
						if (!options.clearAllBlankLinesMode) {
							//  (isComment(token))
							pendingNewLines =
								(pendingNewLines < newLinesInWhitespace)
									? newLinesInWhitespace
									: pendingNewLines;
							pendingNewLines = (pendingNewLines > 2) ? 2 : pendingNewLines;
						}
						if (previousCompilableToken == TokenNameLBRACE && token == TokenNameRBRACE) {
							containsOpenCloseBraces = true;
							indentationLevelForOpenCloseBraces = currentLineIndentationLevel;
							if (isComment(previousToken)) {
								newLine(pendingNewLines);
							} else {
								/*  if (!(constructionsCount > 1
								        && constructions[constructionsCount-1] == NONINDENT_BLOCK
								        && (constructions[constructionsCount-2] == TokenNamefor 
								         || constructions[constructionsCount-2] == TokenNamewhile))) {*/
								if (options.newLineInEmptyBlockMode) {
									if (inArrayAssignment) {
										newLine(1); // array assigment with an empty block
									} else {
										newLine(pendingNewLines);
									}
								}
								// }
							}
						} else {
							// see PR 1FKKC3U: LFCOM:WINNT - Format problem with a comment before the ';'
							if (!((previousToken == TerminalTokens.TokenNameCOMMENT_BLOCK
								|| previousToken == TerminalTokens.TokenNameCOMMENT_JAVADOC)
								&& token == TokenNameSEMICOLON)) {
								newLine(pendingNewLines);
							}
						}
						if (((previousCompilableToken == TokenNameSEMICOLON)
							|| (previousCompilableToken == TokenNameLBRACE)
							|| (previousCompilableToken == TokenNameRBRACE)
							|| (isComment(previousToken)))
							&& (token == TokenNameRBRACE)) {
							indentationOffset = -1;
							indentationLevel += popExclusiveUntilBlock();
						}
						if (previousToken == TerminalTokens.TokenNameCOMMENT_LINE && inAssignment) {
							// PR 1FI5IPO
							currentLineIndentationLevel++;
						} else {
							currentLineIndentationLevel = indentationLevel + indentationOffset;
						}
						pendingSpace = false;
						indentationOffset = 0;
					}
					pendingNewLines = 0;
					newLinesInWhitespace = 0;
					specialElse = false;

					if (nlicsToken == TokenNamedo && token == TokenNamewhile) {
						nlicsToken = 0;
					}
				}
				switch (token) {
					case TokenNameelse :
					case TokenNamefinally :
						expectingOpenBrace = true;
						pendingNewlineAfterParen = true;
						indentationLevel += pushControlStatement(token);
						break;
					case TokenNamecase :
					case TokenNamedefault :
						if (tokenBeforeColonCount == tokenBeforeColon.length) {
							System.arraycopy(
								tokenBeforeColon,
								0,
								(tokenBeforeColon = new int[tokenBeforeColonCount * 2]),
								0,
								tokenBeforeColonCount);
						}
						tokenBeforeColon[tokenBeforeColonCount++] = TokenNamecase;
						indentationLevel += pushControlStatement(TokenNamecase);
						break;
					case TokenNameQUESTION :
						if (tokenBeforeColonCount == tokenBeforeColon.length) {
							System.arraycopy(
								tokenBeforeColon,
								0,
								(tokenBeforeColon = new int[tokenBeforeColonCount * 2]),
								0,
								tokenBeforeColonCount);
						}
						tokenBeforeColon[tokenBeforeColonCount++] = token;
						break;
					case TokenNameswitch :
					case TokenNamefor :
					case TokenNameif :
					case TokenNamewhile :
						if (openParenthesisCount == openParenthesis.length) {
							System.arraycopy(
								openParenthesis,
								0,
								(openParenthesis = new int[openParenthesisCount * 2]),
								0,
								openParenthesisCount);
						}
						openParenthesis[openParenthesisCount++] = 0;
						expectingOpenBrace = true;

						indentationLevel += pushControlStatement(token);
						break;
					case TokenNametry :
						pendingNewlineAfterParen = true;
					case TokenNamecatch :
						// several CATCH statements can be contiguous.
						// a CATCH is encountered pop until first CATCH (if a CATCH follows a TRY it works the same way,
						// as CATCH and TRY are the same token in the stack).
						expectingOpenBrace = true;
						indentationLevel += pushControlStatement(TokenNamecatch);
						break;

					case TokenNamedo :
						expectingOpenBrace = true;
						indentationLevel += pushControlStatement(token);
						nlicsToken = token;
						break;
					case TokenNamenew :
						break;
					case TokenNameLPAREN :
						if (previousToken == TokenNamesynchronized) {
							indentationLevel += pushControlStatement(previousToken);
						} else {
							// Put a space between the previous and current token if the
							// previous token was not a keyword, open paren, logical
							// compliment (eg: !), semi-colon, open brace, close brace,
							// super, or this.
							if (previousCompilableToken != TokenNameLBRACKET
								&& previousToken != TokenNameIdentifier
								&& previousToken != 0
								&& previousToken != TokenNameNOT
								&& previousToken != TokenNameLPAREN
								&& previousToken != TokenNameTWIDDLE
								&& previousToken != TokenNameSEMICOLON
								&& previousToken != TokenNameLBRACE
								&& previousToken != TokenNameRBRACE
								&& previousToken != TokenNamesuper
								&& previousToken != TokenNamethis) {
								space();
							}
							// If in a for/if/while statement, increase the parenthesis count
							// for the current openParenthesisCount
							// else increase the count for stand alone parenthesis.
							if (openParenthesisCount > 0)
								openParenthesis[openParenthesisCount - 1]++;
							else
								openParenthesis[0]++;
	
							pendingSpace = false;
						}
						break;
					case TokenNameRPAREN :

						// Decrease the parenthesis count
						// if there is no more unclosed parenthesis,
						// a new line and indent may be append (depending on the next token).
						if ((openParenthesisCount > 1)
							&& (openParenthesis[openParenthesisCount - 1] > 0)) {
							openParenthesis[openParenthesisCount - 1]--;
							if (openParenthesis[openParenthesisCount - 1] <= 0) {
								pendingNewlineAfterParen = true;
								inAssignment = false;
								openParenthesisCount--;
							}
						} else {
							openParenthesis[0]--;
						}
						pendingSpace = false;
						break;
					case TokenNameLBRACE :
						if ((previousCompilableToken == TokenNameRBRACKET)
							|| (previousCompilableToken == TokenNameEQUAL)) {
							//                  if (previousCompilableToken == TokenNameRBRACKET) {
							inArrayAssignment = true;
							inAssignment = false;
						}
						if (inArrayAssignment) {
							indentationLevel += pushBlock();
						} else {
							// Add new line and increase indentation level after open brace.
							pendingNewLines = 1;
							indentationLevel += pushBlock();
						}
						break;
					case TokenNameRBRACE :
						if (previousCompilableToken == TokenNameRPAREN) {
							pendingSpace = false;
						}
						if (inArrayAssignment) {
							inArrayAssignment = false;
							pendingNewLines = 1;
							indentationLevel += popInclusiveUntilBlock();
						} else {
							pendingNewLines = 1;
							indentationLevel += popInclusiveUntilBlock();

							if (previousCompilableToken == TokenNameRPAREN) {
								// fix for 1FGDDV6: LFCOM:WIN98 - Weird splitting on message expression
								currentLineBuffer.append(options.lineSeparatorSequence);
								increaseLineDelta(options.lineSeparatorSequence.length);
							}
							if (constructionsCount > 0) {
								switch (constructions[constructionsCount - 1]) {
									case TokenNamefor :
										//indentationLevel += popExclusiveUntilBlock();
										//break;
									case TokenNameswitch :
									case TokenNameif :
									case TokenNameelse :
									case TokenNametry :
									case TokenNamecatch :
									case TokenNamefinally :
									case TokenNamewhile :
									case TokenNamedo :
									case TokenNamesynchronized :
										clearNonBlockIndents = true;
									default :
										break;
								}
							}
						}
						break;
					case TokenNameLBRACKET :
						openBracketCount++;
						pendingSpace = false;
						break;
					case TokenNameRBRACKET :
						openBracketCount -= (openBracketCount > 0) ? 1 : 0;
						// if there is no left bracket to close, the right bracket is ignored.
						pendingSpace = false;
						break;
					case TokenNameCOMMA :
					case TokenNameDOT :
						pendingSpace = false;
						break;
					case TokenNameSEMICOLON :

						// Do not generate line terminators in the definition of
						// the for statement.
						// if not in this case, jump a line and reduce indentation after the brace
						// if the block it closes belongs to a conditional statement (if, while, do...).
						if (openParenthesisCount <= 1) {
							pendingNewLines = 1;
							if (expectingOpenBrace) {
								clearNonBlockIndents = true;
								expectingOpenBrace = false;
							}
						}
						inAssignment = false;
						pendingSpace = false;
						break;
					case TokenNamePLUS_PLUS :
					case TokenNameMINUS_MINUS :

						// Do not put a space between a post-increment/decrement
						// and the identifier being modified.
						if (previousToken == TokenNameIdentifier
							|| previousToken == TokenNameRBRACKET) {
							pendingSpace = false;
						}
						break;
					case TokenNamePLUS : // previously ADDITION
					case TokenNameMINUS :

						// Handle the unary operators plus and minus via a flag
						if (!isLiteralToken(previousToken)
							&& previousToken != TokenNameIdentifier
							&& previousToken != TokenNameRPAREN
							&& previousToken != TokenNameRBRACKET) {
							unarySignModifier = 1;
						}
						break;
					case TokenNameCOLON :
						// In a switch/case statement, add a newline & indent
						// when a colon is encountered.
						if (tokenBeforeColonCount > 0) {
							if (tokenBeforeColon[tokenBeforeColonCount - 1] == TokenNamecase) {
								pendingNewLines = 1;
							}
							tokenBeforeColonCount--;
						}
						break;
					case TokenNameEQUAL :
						inAssignment = true;
						break;
					case TerminalTokens.TokenNameCOMMENT_LINE :
						pendingNewLines = 1;
						if (inAssignment) {
							currentLineIndentationLevel++;
						}
						break; // a line is always inserted after a one-line comment
					case TerminalTokens.TokenNameCOMMENT_JAVADOC :
					case TerminalTokens.TokenNameCOMMENT_BLOCK :
						currentCommentOffset = getCurrentCommentOffset();
						pendingNewLines = 1;
						break;
					case TerminalTokens.TokenNameWHITESPACE :

						// Count the number of line terminators in the whitespace so
						// line spacing can be preserved near comments.
						char[] source = scanner.source;
						newLinesInWhitespace = 0;
						for (int i = scanner.startPosition, max = scanner.currentPosition;
							i < max;
							i++) {
							if (source[i] == '\r') {
								if (i < max - 1) {
									if (source[++i] == '\n') {
										newLinesInWhitespace++;
									} else {
										newLinesInWhitespace++;
									}
								} else {
									newLinesInWhitespace++;
								}
							} else if (source[i] == '\n') {
									newLinesInWhitespace++;
							}
						}
						increaseLineDelta(scanner.startPosition - scanner.currentPosition);
						break;
					default :
						if ((token == TokenNameIdentifier)
							|| isLiteralToken(token)
							|| token == TokenNamesuper
							|| token == TokenNamethis) {

							// Do not put a space between a unary operator
							// (eg: ++, --, +, -) and the identifier being modified.
							if (previousToken == TokenNamePLUS_PLUS
								|| previousToken == TokenNameMINUS_MINUS
								|| (previousToken == TokenNamePLUS && unarySignModifier > 0)
								|| (previousToken == TokenNameMINUS && unarySignModifier > 0)) {
								pendingSpace = false;
							}
							unarySignModifier = 0;
						}
						break;
				}
				// Do not output whitespace tokens.
				if (token != TerminalTokens.TokenNameWHITESPACE) {

					/* Add pending space to the formatted source string.
					Do not output a space under the following circumstances:
					1) this is the first pass
					2) previous token is an open paren
					3) previous token is a period
					4) previous token is the logical compliment (eg: !)
					5) previous token is the bitwise compliment (eg: ~)
					6) previous token is the open bracket (eg: [)
					7) in an assignment statement, if the previous token is an 
					open brace or the current token is a close brace
					8) previous token is a single line comment
					*/
					boolean openAndCloseBrace =
						previousCompilableToken == TokenNameLBRACE && token == TokenNameRBRACE;

					if (pendingSpace
						&& insertSpaceAfter(previousToken)
						&& !(inAssignment
							&& (previousToken == TokenNameLBRACE || token == TokenNameRBRACE))
						&& previousToken != TerminalTokens.TokenNameCOMMENT_LINE) {
						if ((!(options.compactAssignmentMode && token == TokenNameEQUAL))
							&& !openAndCloseBrace) {
								if (previousCompilableToken == TokenNameRPAREN) {
									switch(token) {
										case TokenNameIdentifier :
										case TokenNameDoubleLiteral :
										case TokenNameIntegerLiteral :
										case TokenNameFloatingPointLiteral :
										case TokenNameStringLiteral :
										case TokenNameCharacterLiteral :
										case TokenNameLongLiteral :
										case TokenNamenew :
										case TokenNamethis :
										case TokenNamesuper :
										case TokenNameboolean :
										case TokenNamebyte :
										case TokenNamechar :
										case TokenNameint :
										case TokenNamelong :
										case TokenNameshort :
										case TokenNamedouble :
										case TokenNamefloat :
											if (options.isAddindSpaceInCastExpression()) {
												space();
											}
											break;
										default:
											space();
									}
								} else {
									space();
								}
						}
					}
					// Add the next token to the formatted source string.
					outputCurrentToken(token);
					if (token == TerminalTokens.TokenNameCOMMENT_LINE && openParenthesisCount > 1) {
						pendingNewLines = 0;
						currentLineBuffer.append(options.lineSeparatorSequence);
						increaseLineDelta(options.lineSeparatorSequence.length);
					}
					pendingSpace = true;
				}
				// Whitespace tokens do not need to be remembered.
				if (token != TerminalTokens.TokenNameWHITESPACE) {
					previousToken = token;
					if (token != TerminalTokens.TokenNameCOMMENT_BLOCK
						&& token != TerminalTokens.TokenNameCOMMENT_LINE
						&& token != TerminalTokens.TokenNameCOMMENT_JAVADOC) {
						previousCompilableToken = token;
					}
				}
			}
			output(copyRemainingSource());
			flushBuffer(); // dump the last token of the source in the formatted output.
		} catch (InvalidInputException e) {
			output(copyRemainingSource());
			flushBuffer(); // dump the last token of the source in the formatted output.
		}
	}

