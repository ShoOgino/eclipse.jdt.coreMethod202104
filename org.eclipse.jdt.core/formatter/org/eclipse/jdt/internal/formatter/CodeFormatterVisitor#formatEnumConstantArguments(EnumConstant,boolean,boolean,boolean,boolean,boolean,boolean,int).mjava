	private void formatEnumConstantArguments(
			EnumConstant enumConstant,
			boolean spaceBeforeOpenParen, 
			boolean spaceBetweenEmptyParameters,
			boolean spaceBeforeClosingParen, 
			boolean spaceBeforeFirstParameter, 
			boolean spaceBeforeComma, 
			boolean spaceAfterComma,
			int methodDeclarationParametersAlignment) {
				
		if (!isNextToken(TerminalTokens.TokenNameLPAREN)) {
			return;
		}
		
		this.scribe.printNextToken(TerminalTokens.TokenNameLPAREN, spaceBeforeOpenParen); 
		final Expression[] arguments = enumConstant.arguments;
		if (arguments != null) {
			int argumentLength = arguments.length;
			Alignment argumentsAlignment = this.scribe.createAlignment(
					"enumConstantArguments",//$NON-NLS-1$
					methodDeclarationParametersAlignment,
					argumentLength,
					this.scribe.scanner.currentPosition);
			this.scribe.enterAlignment(argumentsAlignment);
			boolean ok = false;
			do {
				try {
					if (spaceBeforeFirstParameter) {
						this.scribe.space();
					}
					for (int i = 0; i < argumentLength; i++) {
						if (i > 0) {
							this.scribe.printNextToken(TerminalTokens.TokenNameCOMMA, spaceBeforeComma);
							this.scribe.printTrailingComment();
						}
						this.scribe.alignFragment(argumentsAlignment, i);
						if (i > 0 && spaceAfterComma) {
							this.scribe.space();
						}
						arguments[i].traverse(this, (BlockScope) null);
					}
					ok = true;
				} catch (AlignmentException e) {
					this.scribe.redoAlignment(e);
				}
			} while (!ok);
			this.scribe.exitAlignment(argumentsAlignment, true);
		
			this.scribe.printNextToken(TerminalTokens.TokenNameRPAREN, spaceBeforeClosingParen); 
		} else {
			this.scribe.printNextToken(TerminalTokens.TokenNameRPAREN, spaceBetweenEmptyParameters); 
		}	
	}

