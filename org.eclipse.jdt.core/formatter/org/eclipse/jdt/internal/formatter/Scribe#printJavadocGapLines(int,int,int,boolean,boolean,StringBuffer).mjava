	/*
	 * prints the empty javadoc line between the 2 given positions.
	 * May insert new '*' before each new line
	 */
	private void printJavadocGapLines(int textStartPosition, int textEndPosition, int newLines, boolean clearBlankLines, boolean footer, StringBuffer output) {
		try {
			// If no lines to set in the gap then just insert a space if there's enough room to
			if (newLines == 0) {
				if (output == null) {
					addReplaceEdit(textStartPosition, textEndPosition,  " "); //$NON-NLS-1$
				} else {
					output.append(' ');
				}
				this.column++;
				return;
			}

			// if there's no enough room to replace text, then insert the gap
			if (textStartPosition > textEndPosition) {
				if (newLines > 0) {
					this.javadocGapLinesBuffer.setLength(0);
					for (int i=0; i<newLines; i++) {
						this.javadocGapLinesBuffer.append(this.lineSeparator);
						this.column = 1;
						printIndentationIfNecessary(this.javadocGapLinesBuffer);
						if (footer) {
							this.javadocGapLinesBuffer.append(' ');
							this.column++;
						} else {
							this.javadocGapLinesBuffer.append(BLOCK_LINE_PREFIX);
							this.column += BLOCK_LINE_PREFIX_LENGTH;
						}
					}
					if (output == null) {
						addInsertEdit(textStartPosition, this.javadocGapLinesBuffer.toString());
					} else {
						output.append(this.javadocGapLinesBuffer);
					}
				}
				return;
			}

			// There's enough room and some lines to set...
			// Skip the text token per token to keep existing stars when possible
			this.scanner.resetTo(textStartPosition, textEndPosition);
			this.scanner.recordLineSeparator = true;
			this.scanner.linePtr = Util.getLineNumber(textStartPosition, this.lineEnds, 0, this.maxLines) - 2;
			int linePtr = this.scanner.linePtr;
			int lineCount = 0;
			int start = textStartPosition;
			boolean endsOnMultiply = false;
			while (!this.scanner.atEnd()) {
				switch (this.scanner.getNextToken()) {
					case TerminalTokens.TokenNameMULTIPLY:
						// we just need to replace each lines between '*' with the javadoc formatted ones
						int linesGap = this.scanner.linePtr - linePtr;
						if (linesGap > 0) {
							this.javadocGapLinesBuffer.setLength(0);
							if (lineCount > 0) {
								// only add trailing space if one was there before (bug 49619)
								if (this.scanner.source[start] == ' ') {
									this.javadocGapLinesBuffer.append(' ');
								}
							}
							for (int i = 0; i < linesGap ; i++) {
								if (clearBlankLines && lineCount >= newLines) {
									// leave as the required new lines have been inserted
									// so remove any remaining blanks and leave
									if (textEndPosition >= start) {
										if (output == null) {
											addReplaceEdit(start, textEndPosition, " "); //$NON-NLS-1$
										} else {
											output.append(' ');
										}
									}
									return;
								}
								this.javadocGapLinesBuffer.append(this.lineSeparator);
								this.column = 1;
								printIndentationIfNecessary(this.javadocGapLinesBuffer);
								if (i == (linesGap-1)) {
									this.javadocGapLinesBuffer.append(' ');
									this.column++;
								} else {
									this.javadocGapLinesBuffer.append(BLOCK_LINE_PREFIX);
									this.column += BLOCK_LINE_PREFIX_LENGTH;
								}
								lineCount++;
							}
							int currentTokenStartPosition = this.scanner.getCurrentTokenStartPosition();
							int tokenLength = this.scanner.currentPosition - currentTokenStartPosition;
							if (output == null) {
								addReplaceEdit(start, currentTokenStartPosition-1, this.javadocGapLinesBuffer.toString());
							} else {
								output.append(this.javadocGapLinesBuffer);
								output.append(this.scanner.source, currentTokenStartPosition, tokenLength);
							}
							this.column += tokenLength;
							if (footer && clearBlankLines && lineCount == newLines) {
								if (textEndPosition >= currentTokenStartPosition) {
									if (output == null) {
										addDeleteEdit(currentTokenStartPosition, textEndPosition);
									}
								}
								return;
							}
						}
						// next start is just after the current token
						start = this.scanner.currentPosition;
						linePtr = this.scanner.linePtr;
						endsOnMultiply = true;
						break;
					default:
						endsOnMultiply = false;
						break;
				}
			}

			// Format the last whitespaces
			if (lineCount < newLines) {
				// Insert new lines as not enough was encountered while scanning the whitespaces
				this.javadocGapLinesBuffer.setLength(0);
				if (lineCount > 0) {
					// only add trailing space if one was there before (bug 49619)
					if (this.scanner.source[start] == ' ') {
						this.javadocGapLinesBuffer.append(' ');
					}
				}
				for (int i = lineCount; i < newLines-1; i++) {
					printJavadocNewLine(this.javadocGapLinesBuffer);
				}
				this.javadocGapLinesBuffer.append(this.lineSeparator);
				this.column = 1;
				printIndentationIfNecessary(this.javadocGapLinesBuffer);
				if (footer) {
					this.javadocGapLinesBuffer.append(' ');
					this.column++;
				} else {
					this.javadocGapLinesBuffer.append(BLOCK_LINE_PREFIX);
					this.column += BLOCK_LINE_PREFIX_LENGTH;
				}
				if (output == null) {
					if (textEndPosition >= start) {
						addReplaceEdit(start, textEndPosition, this.javadocGapLinesBuffer.toString());
					} else {
						addInsertEdit(textEndPosition+1, this.javadocGapLinesBuffer.toString());
					}
				} else {
					output.append(this.javadocGapLinesBuffer);
				}
			} else {
				// Replace all remaining whitespaces by a single space
				if (textEndPosition >= start) {
					this.javadocGapLinesBuffer.setLength(0);
					if (this.scanner.linePtr > linePtr) {
						if (lineCount > 0) {
							// only add trailing space if one was there before (bug 49619)
							if (this.scanner.source[start] == ' ') {
								this.javadocGapLinesBuffer.append(' ');
							}
						}
						this.javadocGapLinesBuffer.append(this.lineSeparator);
						this.column = 1;
						printIndentationIfNecessary(this.javadocGapLinesBuffer);
					}
					this.javadocGapLinesBuffer.append(' ');
					if (output == null) {
						addReplaceEdit(start, textEndPosition, this.javadocGapLinesBuffer.toString());
					} else {
						output.append(this.javadocGapLinesBuffer);
					}
					this.needSpace = false;
				} else if (endsOnMultiply) {
					if (output == null) {
						addInsertEdit(textEndPosition+1, " "); //$NON-NLS-1$
					} else {
						output.append(' ');
					}
					this.needSpace = false;
				}
				this.column++;
			}
		}
		catch (InvalidInputException iie) {
			// there's nothing to do if this exception happens
		}
		finally {
			this.scanner.recordLineSeparator = false;
			this.needSpace = false;
			this.scanner.resetTo(textEndPosition+1, this.scannerEndPosition - 1);
			this.lastNumberOfNewLines += newLines;
			this.line += newLines;
		}
	}

