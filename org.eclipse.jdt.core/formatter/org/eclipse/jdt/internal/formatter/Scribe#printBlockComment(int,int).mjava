	private boolean printBlockComment(int currentTokenStartPosition, int currentTokenEndPosition) {

		// Compute indentation
		int maxColumn = this.formatter.preferences.comment_line_length + 1;
		int indentLevel = this.indentationLevel;
		int indentations = this.numberOfIndentations;
		switch (this.tabChar) {
			case DefaultCodeFormatterOptions.TAB:
				switch (this.tabLength) {
					case 0:
						this.indentationLevel = 0;
						this.column = 1;
						this.numberOfIndentations = 0;
						break;
					case 1:
						this.indentationLevel = this.column - 1;
						this.numberOfIndentations = this.indentationLevel;
						break;
					default:
						this.indentationLevel = (this.column / this.tabLength) * this.tabLength;
						this.column = this.indentationLevel + 1;
						this.numberOfIndentations = this.indentationLevel / this.tabLength;
				}
				break;
			case DefaultCodeFormatterOptions.MIXED:
				if (this.tabLength == 0) {
					this.indentationLevel = 0;
					this.column = 1;
					this.numberOfIndentations = 0;
				} else {
					this.indentationLevel = this.column - 1;
					this.numberOfIndentations = this.indentationLevel / this.tabLength;
				}
				break;
			case DefaultCodeFormatterOptions.SPACE:
				if (this.indentationSize == 0) {
					this.indentationLevel = 0;
					this.column = 1;
					this.numberOfIndentations = 0;
				} else {
					this.indentationLevel = this.column - 1;
				}
				break;
		}

		// Consume the comment prefix
		this.blockCommentBuffer.setLength(0);
		this.scanner.getNextChar();
		this.scanner.getNextChar();
		this.column += 2;
		this.scanner.skipComments = true;
		this.blockCommentTokensBuffer.setLength(0);
		int editStart = this.scanner.currentPosition;
		int editEnd = -1;

		// Consume text token per token
		int previousToken = -1;
		boolean newLine = false;
		boolean multiLines = false;
		boolean hasMultiLines = false;
		boolean hasTokens = false;
		boolean bufferHasTokens = false;
		boolean bufferHasNewLine = false;
		boolean lineHasTokens = false;
		int hasTextOnFirstLine = 0;
		boolean firstWord = true;
		boolean clearBlankLines = this.formatter.preferences.comment_clear_blank_lines_in_block_comment;
		boolean joinLines = this.formatter.preferences.join_lines_in_comments;
		boolean newLinesAtBoundaries = this.formatter.preferences.comment_new_lines_at_block_boundaries;
		int scannerLine = Util.getLineNumber(this.scanner.currentPosition, this.lineEnds, 0, this.maxLines);
		int firstLine = scannerLine;
		int lineNumber = scannerLine;
		int lastTextLine = -1;
		while (!this.scanner.atEnd()) {

			// Consume token
			int token;
			try {
				token = this.scanner.getNextToken();
			} catch (InvalidInputException iie) {
	    		token = consumeInvalidToken(currentTokenEndPosition-1);
				newLine = false;
			}

			// Look at specific tokens
    		boolean insertSpace = (previousToken == TerminalTokens.TokenNameWHITESPACE) && (!firstWord || !hasTokens);
    		boolean isTokenStar = false;
			switch (token) {
				case TerminalTokens.TokenNameWHITESPACE:
					if (this.blockCommentTokensBuffer.length() > 0) {
						if (hasTextOnFirstLine == 1 && multiLines) {
							printBlockCommentHeaderLine(this.blockCommentBuffer);
							hasTextOnFirstLine = -1;
						}
						this.blockCommentBuffer.append(this.blockCommentTokensBuffer);
						this.column += this.blockCommentTokensBuffer.length();
						this.blockCommentTokensBuffer.setLength(0);
						bufferHasTokens = true;
						bufferHasNewLine = false;
					}
					if (previousToken == -1) {
						// do not remember the first whitespace
						previousToken = SKIP_FIRST_WHITESPACE_TOKEN;
					} else {
						previousToken = token;
					}
					lineNumber = Util.getLineNumber(this.scanner.currentPosition, this.lineEnds, scannerLine>1 ? scannerLine-2 : 0, this.maxLines);
					if (lineNumber > scannerLine) {
						hasMultiLines = true;
						newLine = true;
					}
					scannerLine = lineNumber;
					continue;
				case TerminalTokens.TokenNameMULTIPLY:
					isTokenStar = true;
					lineNumber = Util.getLineNumber(this.scanner.currentPosition, this.lineEnds, scannerLine>1 ? scannerLine-2 : 0, this.maxLines);
					if (lineNumber == firstLine && previousToken == SKIP_FIRST_WHITESPACE_TOKEN) {
						this.blockCommentBuffer.append(' ');
					}
					previousToken = token;
					if (this.scanner.currentCharacter == '/') {
						editEnd = this.scanner.startPosition - 1;
						// Add remaining buffered tokens
						if (this.blockCommentTokensBuffer.length() > 0) {
							this.blockCommentBuffer.append(this.blockCommentTokensBuffer);
							this.column += this.blockCommentTokensBuffer.length();
						}
						// end of comment
						if (newLinesAtBoundaries) {
							if (multiLines || hasMultiLines) {
						    	this.blockCommentBuffer.append(this.lineSeparator);
						    	this.column = 1;
						    	printIndentationIfNecessary(this.blockCommentBuffer);
							}
						}
						this.blockCommentBuffer.append(' ');
						this.column += BLOCK_FOOTER_LENGTH + 1;
				    	this.scanner.getNextChar(); // reach the end of scanner
				    	continue;
					}
					if (newLine) {
						scannerLine = lineNumber;
						newLine = false;
						continue;
					}
					break;
				case TerminalTokens.TokenNameMULTIPLY_EQUAL:
					if (newLine) {
						this.scanner.resetTo(this.scanner.startPosition, currentTokenEndPosition-1);
						this.scanner.getNextChar(); // consume the multiply
						previousToken = TerminalTokens.TokenNameMULTIPLY;
						scannerLine = Util.getLineNumber(this.scanner.currentPosition, this.lineEnds, scannerLine>1 ? scannerLine-2 : 0, this.maxLines);
						continue;
					}
					break;
				case TerminalTokens.TokenNameMINUS:
				case TerminalTokens.TokenNameMINUS_MINUS:
					if (previousToken == -1) {
						// Do not format comment starting with /*-
						// see bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=230944
						this.indentationLevel = indentLevel;
						this.numberOfIndentations = indentations;
						this.lastNumberOfNewLines = 0;
						this.needSpace = false;
						this.scanner.skipComments = false;
						this.scanner.resetTo(currentTokenStartPosition, currentTokenEndPosition - 1);
						return false;
					}
					break;
				default:
					// do nothing
					break;
			}

			// Look at gap and insert corresponding lines if necessary
			int linesGap;
			int max;
			lineNumber = Util.getLineNumber(this.scanner.currentPosition, this.lineEnds, scannerLine>1 ? scannerLine-2 : 0, this.maxLines);
			if (lastTextLine == -1) {
				linesGap = newLinesAtBoundaries ? lineNumber - firstLine : 0;
				max = 0;
			} else {
				linesGap = lineNumber - lastTextLine;
				if (token == TerminalTokens.TokenNameAT && linesGap ==1) {
					// insert one blank line before root tags
					linesGap = 2;
				}
				max = joinLines && lineHasTokens ? 1 : 0;
			}
			if (linesGap > max) {
				if (clearBlankLines) {
					// TODO (frederic) see if there's a bug for the unremoved blank line for root tags
					 if (token == TerminalTokens.TokenNameAT) {
						 linesGap = 1;
					 } else {
						linesGap = (max==0 || !joinLines) ? 1 : 0;
					 }
				}
				for (int i=0; i<linesGap; i++) {
					// Add remaining buffered tokens
					if (this.blockCommentTokensBuffer.length() > 0) {
						if (hasTextOnFirstLine == 1) {
							printBlockCommentHeaderLine(this.blockCommentBuffer);
							hasTextOnFirstLine = -1;
						}
						this.blockCommentBuffer.append(this.blockCommentTokensBuffer);
						this.blockCommentTokensBuffer.setLength(0);
						bufferHasTokens = true;
					}
			    	this.blockCommentBuffer.append(this.lineSeparator);
			    	this.column = 1;
			    	printIndentationIfNecessary(this.blockCommentBuffer);
		    		this.blockCommentBuffer.append(BLOCK_LINE_PREFIX);
		    		this.column += BLOCK_LINE_PREFIX_LENGTH;
		    		firstWord = true;
					multiLines = true;
					bufferHasNewLine = true;
				}
				insertSpace = insertSpace && linesGap == 0;
			}
    		if (newLine) lineHasTokens = false;

			// Increment column
			int tokenStart = this.scanner.getCurrentTokenStartPosition();
    		int tokenLength = (this.scanner.atEnd() ? this.scanner.eofPosition : this.scanner.currentPosition) - tokenStart;
    		hasTokens = true;
    		if (!isTokenStar) lineHasTokens = true;
    		if (hasTextOnFirstLine == 0 && !isTokenStar) {
    			if (firstLine == lineNumber) {
	    			hasTextOnFirstLine = 1;
	    			this.column++; // include first space
	    		} else {
	    			hasTextOnFirstLine = -1;
	    		}
    		}
    		int lastColumn = this.column + this.blockCommentTokensBuffer.length() + tokenLength;
    		if (insertSpace) lastColumn++;

    		// Append next token inserting a new line if max line is reached
			if (lineHasTokens && !firstWord && lastColumn > maxColumn) {
		    	String tokensString = this.blockCommentTokensBuffer.toString().trim();
		    	int tokensStringLength = tokensString.length();
				// not enough space on the line
				if (hasTextOnFirstLine == 1) {
					printBlockCommentHeaderLine(this.blockCommentBuffer);
				}
				if ((this.indentationLevel+tokensStringLength+tokenLength) > maxColumn) {
					// there won't be enough room even if we break the line before the buffered tokens
					// So add the buffered tokens now
					this.blockCommentBuffer.append(this.blockCommentTokensBuffer);
					this.column += this.blockCommentTokensBuffer.length();
					this.blockCommentTokensBuffer.setLength(0);
					bufferHasNewLine = false;
					bufferHasTokens = true;
				}
				if (bufferHasTokens && !bufferHasNewLine) {
			    	this.blockCommentBuffer.append(this.lineSeparator);
			    	this.column = 1;
			    	printIndentationIfNecessary(this.blockCommentBuffer);
		    		this.blockCommentBuffer.append(BLOCK_LINE_PREFIX);
			    	this.column += BLOCK_LINE_PREFIX_LENGTH;
				}
		    	if (this.blockCommentTokensBuffer.length() > 0) {
					this.blockCommentBuffer.append(tokensString);
					this.column += tokensStringLength;
					this.blockCommentTokensBuffer.setLength(0);
		    	}
				this.blockCommentBuffer.append(this.scanner.source, tokenStart, tokenLength);
				bufferHasTokens = true;
				bufferHasNewLine = false;
				this.column += tokenLength;
				multiLines = true;
				hasTextOnFirstLine = -1;
			} else {
				// append token to the line
				if (insertSpace)  {
					this.blockCommentTokensBuffer.append(' ');
				}
				this.blockCommentTokensBuffer.append(this.scanner.source, tokenStart, tokenLength);
			}
			previousToken = token;
			newLine = false;
    		firstWord = false;
			scannerLine = lineNumber;
			lastTextLine = lineNumber;
		}

		// Replace block comment text
		if (this.nlsTagCounter == 0 || !multiLines) {
			if (hasTokens || multiLines) {
				StringBuffer replacement;
				if (hasTextOnFirstLine == 1) {
					this.blockCommentTokensBuffer.setLength(0);
					replacement = this.blockCommentTokensBuffer;
					if ((hasMultiLines || multiLines)) {
						int col = this.column;
						replacement.append(this.lineSeparator);
						this.column = 1;
						printIndentationIfNecessary(replacement);
						replacement.append(BLOCK_LINE_PREFIX);
				    	this.column = col;
					} else if (this.blockCommentBuffer.length()==0 || this.blockCommentBuffer.charAt(0)!=' ') {
						replacement.append(' ');
					}
					replacement.append(this.blockCommentBuffer);
				} else {
					replacement = this.blockCommentBuffer;
				}
				addReplaceEdit(editStart, editEnd, replacement.toString());
			}
		}

		// Reset
		this.indentationLevel = indentLevel;
		this.numberOfIndentations = indentations;
		this.lastNumberOfNewLines = 0;
		this.needSpace = false;
		this.scanner.resetTo(currentTokenEndPosition, this.scannerEndPosition - 1);
		this.scanner.skipComments = false;
		return true;
	}

