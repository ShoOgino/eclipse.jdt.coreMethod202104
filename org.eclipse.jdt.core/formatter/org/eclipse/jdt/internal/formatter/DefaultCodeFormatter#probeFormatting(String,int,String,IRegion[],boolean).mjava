	private TextEdit probeFormatting(String source, int indentationLevel, String lineSeparator, IRegion[] regions, boolean includeComments) {
		if (PROBING_SCANNER == null) {
			// scanner use to check if the kind could be K_JAVA_DOC, K_MULTI_LINE_COMMENT or K_SINGLE_LINE_COMMENT
			// do not tokenize white spaces to get single comments even with spaces before...
			PROBING_SCANNER = new Scanner(true, false/*do not tokenize whitespaces*/, false/*nls*/, ClassFileConstants.JDK1_6, ClassFileConstants.JDK1_6, null/*taskTags*/, null/*taskPriorities*/, true/*taskCaseSensitive*/);
		}
		PROBING_SCANNER.setSource(source.toCharArray());

		IRegion coveredRegion = getCoveredRegion(regions);
		int offset = coveredRegion.getOffset();
		int length = coveredRegion.getLength();

		PROBING_SCANNER.resetTo(offset, offset + length - 1);
		try {
			int kind = -1;
			switch(PROBING_SCANNER.getNextToken()) {
				case ITerminalSymbols.TokenNameCOMMENT_BLOCK :
					if (PROBING_SCANNER.getNextToken() == TerminalTokens.TokenNameEOF) {
						kind = K_MULTI_LINE_COMMENT;
					}
					break;
				case ITerminalSymbols.TokenNameCOMMENT_LINE :
					if (PROBING_SCANNER.getNextToken() == TerminalTokens.TokenNameEOF) {
						kind = K_SINGLE_LINE_COMMENT;
					}
					break;
				case ITerminalSymbols.TokenNameCOMMENT_JAVADOC :
					if (PROBING_SCANNER.getNextToken() == TerminalTokens.TokenNameEOF) {
						kind = K_JAVA_DOC;
					}
					break;
			}
			if (kind != -1) {
				return formatComment(kind, source, indentationLevel, lineSeparator, regions);
			}
		} catch (InvalidInputException e) {
			// ignore
		}
		PROBING_SCANNER.setSource((char[]) null);

		// probe for expression
		Expression expression = this.codeSnippetParsingUtil.parseExpression(source.toCharArray(), this.defaultCompilerOptions, true);
		if (expression != null) {
			return internalFormatExpression(source, indentationLevel, lineSeparator, expression, regions, includeComments);
		}

		// probe for body declarations (fields, methods, constructors)
		ASTNode[] bodyDeclarations = this.codeSnippetParsingUtil.parseClassBodyDeclarations(source.toCharArray(), this.defaultCompilerOptions, true);
		if (bodyDeclarations != null) {
			return internalFormatClassBodyDeclarations(source, indentationLevel, lineSeparator, bodyDeclarations, regions, includeComments);
		}

		// probe for statements
		ConstructorDeclaration constructorDeclaration = this.codeSnippetParsingUtil.parseStatements(source.toCharArray(), this.defaultCompilerOptions, true, false);
		if (constructorDeclaration.statements != null) {
			return internalFormatStatements(source, indentationLevel, lineSeparator, constructorDeclaration, regions, includeComments);
		}

		// this has to be a compilation unit
		return formatCompilationUnit(source, indentationLevel, lineSeparator, regions, includeComments);
	}

