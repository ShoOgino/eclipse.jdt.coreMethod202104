	private int printJavadocBlockNodesNewLines(FormatJavadocBlock block, FormatJavadocNode node, int previousEnd) {
	   	int maxColumn = this.formatter.preferences.comment_line_length+1;
    	int nodeStart = node.sourceStart;
 	    try {
			this.scanner.resetTo(nodeStart , node.sourceEnd);
	    	int length = 0;
	    	boolean newLine = false;
			boolean headerLine = block.isHeaderLine() && this.lastNumberOfNewLines == 0;
			int firstColumn = 1 + this.indentationLevel + BLOCK_LINE_PREFIX_LENGTH;
			if (this.commentIndentation != null) firstColumn += this.commentIndentation.length();
			if (headerLine) maxColumn++;
			FormatJavadocText text = null;
			boolean isImmutableNode = node.isImmutable();
			boolean nodeIsText = node.isText();
			if (nodeIsText) {
	    		text = (FormatJavadocText)node;
			} else {
				FormatJavadocBlock inlinedBlock = (FormatJavadocBlock)node;
				if (isImmutableNode) {
					text = (FormatJavadocText) inlinedBlock.getLastNode();
					if (text != null) {
			    		length += inlinedBlock.tagEnd - inlinedBlock.sourceStart + 1;  // tag length
				    	if (nodeStart > (previousEnd+1)) {
				    		length++; // include space between nodes
				    	}
						this.scanner.resetTo(text.sourceStart , node.sourceEnd);
					}
				}
			}
	    	if (text != null) {
    			if (isImmutableNode) {
			    	if (nodeStart > (previousEnd+1)) {
			    		length++; // include space between nodes
			    	}
    				int lastColumn = this.column + length;
	    			while (!this.scanner.atEnd()) {
	    				try {
		    				int token = this.scanner.getNextToken();
		    				switch (token) {
		    					case TerminalTokens.TokenNameWHITESPACE:
		    						if (CharOperation.indexOf('\n', this.scanner.source, this.scanner.startPosition, this.scanner.currentPosition) >= 0) {
		    							return 0;
		    						}
									lastColumn = getCurrentIndentation(this.scanner.getCurrentTokenSource(), lastColumn);
		    						break;
		    					case TerminalTokens.TokenNameMULTIPLY:
		    						if (newLine) {
		    							newLine = false;
		    							continue;
		    						}
		    						lastColumn++;
		    						break;
		    					default:
					    			lastColumn += (this.scanner.atEnd() ? this.scanner.eofPosition : this.scanner.currentPosition) - this.scanner.startPosition;
		    						break;
		    				}
	    				}
	    				catch (InvalidInputException iie) {
	    					// maybe an unterminated string or comment
			    			lastColumn += (this.scanner.atEnd() ? this.scanner.eofPosition : this.scanner.currentPosition) - this.scanner.startPosition;
	    				}
	    				if (lastColumn > maxColumn) {
	    					return 1;
						}
	    			}
	    			return 0;
    			}
    			if (text.isHtmlTag()) {
    				if (text.getHtmlTagID() == JAVADOC_SINGLE_BREAK_TAG_ID) {
    					// never break before single break tag
    					return 0;
    				}
	    			// read the html tag
    				this.scanner.getNextToken();
	    			if (this.scanner.getNextToken() == TerminalTokens.TokenNameDIVIDE) {
	    				length++;
	    				this.scanner.getNextToken();
	    			}
	    			length += (this.scanner.atEnd() ? this.scanner.eofPosition : this.scanner.currentPosition) - this.scanner.startPosition;
	    			this.scanner.getNextToken(); // '>'
	    			length++;
	    		} else {
	    			while (true) {
	    				int token = this.scanner.getNextToken();
	    				if (token == TerminalTokens.TokenNameWHITESPACE || token == TerminalTokens.TokenNameEOF) break;
		    			int tokenLength = (this.scanner.atEnd() ? this.scanner.eofPosition : this.scanner.currentPosition) - this.scanner.startPosition;
		    			length += tokenLength;
		    			if ((this.column + length) >= maxColumn) {
		    				break;
		    			}
	    			}
	    		}
	    	} else {
	    		FormatJavadocBlock inlinedBlock = (FormatJavadocBlock) node;
	    		length += inlinedBlock.tagEnd - inlinedBlock.sourceStart + 1;  // tag length
	    		if (inlinedBlock.reference != null) {
		    		length++; // space between tag and reference
					this.scanner.resetTo(inlinedBlock.reference.sourceStart, inlinedBlock.reference.sourceEnd);
					int previousToken = -1;
					loop: while (!this.scanner.atEnd()) {
						int token = this.scanner.getNextToken();
			    		int tokenLength = (this.scanner.atEnd() ? this.scanner.eofPosition : this.scanner.currentPosition) - this.scanner.startPosition;
						switch (token) {
							case TerminalTokens.TokenNameWHITESPACE:
								if (previousToken == TerminalTokens.TokenNameCOMMA) { // space between method arguments
									length++;
								}
								break;
							case TerminalTokens.TokenNameMULTIPLY:
								break;
							default:
								length += tokenLength;
								if ((this.column+length) > maxColumn) {
									break loop;
								}
					    		break;
						}
						previousToken = token;
		    		}
	    		}
	    		length++; // one more for closing brace
	    	}
	    	if (nodeStart > (previousEnd+1)) {
	    		length++; // include space between nodes
	    	}
    		if ((firstColumn + length) >= maxColumn && node == block.nodes[0]) {
    			// Do not split in this peculiar case as length would be also over the max
    			// length on next line
    			return 0;
    		}
			if ((this.column + length) > maxColumn) {
	    		return 1;
	    	}
	    } catch (InvalidInputException iie) {
	    	// Assume length is one
	    	int tokenLength = 1;
	    	if (nodeStart > (previousEnd+1)) {
	    		tokenLength++; // include space between nodes
	    	}
			if ((this.column + tokenLength) > maxColumn) {
	    		return 1;
	    	}
	    }
	    return 0;
    }

