	private void printLineComment(int commentStart, int commentEnd) {

		// Compute indentation
		int firstColumn = this.column;
		int indentLevel = this.indentationLevel;
		int indentations = this.numberOfIndentations;
		this.indentationLevel = getNextIndentationLevel(firstColumn);
		if (this.indentationSize != 0) {
			this.numberOfIndentations = this.indentationLevel / this.indentationSize;
		}
		else{
			this.numberOfIndentations = 0;
		}

		// Consume the comment prefix
		this.scanner.resetTo(commentStart, commentEnd);
		this.scanner.getNextChar();
		this.scanner.getNextChar();
		this.column += 2;

		// Scan the text token per token to compact it and size it the max line length
		int maxColumn = this.formatter.preferences.comment_line_length + 1;
		int previousToken = -1;
		int lastTokenEndPosition = commentStart;
		int spaceStartPosition = -1;
		int spaceEndPosition = -1;
		this.scanner.skipComments = true;
		String newLineString = null;
		this.commentIndentation = null;

		// Consume text token per token
		while (!this.scanner.atEnd()) {
			int token;
			try {
				token = this.scanner.getNextToken();
			} catch (InvalidInputException iie) {
	    		token = consumeInvalidToken(commentEnd);
			}
			switch (token) {
				case TerminalTokens.TokenNameWHITESPACE:
					if (previousToken == -1) {
						// do not remember the first whitespace
						previousToken = SKIP_FIRST_WHITESPACE_TOKEN;
					} else {
						previousToken = token;
					}
					// Remember space position
					spaceStartPosition = this.scanner.getCurrentTokenStartPosition();
					spaceEndPosition = this.scanner.getCurrentTokenEndPosition();
					continue;
				case TerminalTokens.TokenNameEOF:
					continue;
				case TerminalTokens.TokenNameIdentifier:
					if (previousToken == -1 || previousToken == SKIP_FIRST_WHITESPACE_TOKEN) {
						char[] identifier = this.scanner.getCurrentTokenSource();
						int startPosition = this.scanner.getCurrentTokenStartPosition();
						int restartPosition = this.scanner.currentPosition;
						if (CharOperation.equals(identifier, Parser.FALL_THROUGH_TAG, 0, 5/*length of string "$FALL"*/) && this.scanner.currentCharacter == '-') {
							try {
								this.scanner.getNextToken(); //  consume the '-'
								token = this.scanner.getNextToken(); // consume the "THROUGH"
								if (token == TerminalTokens.TokenNameIdentifier) {
									identifier = this.scanner.getCurrentTokenSource();
									if (CharOperation.endsWith(Parser.FALL_THROUGH_TAG, identifier)) {
										// the comment starts with a fall through
										if (previousToken == SKIP_FIRST_WHITESPACE_TOKEN) {
											addReplaceEdit(spaceStartPosition, startPosition-1, " "); //$NON-NLS-1$
										}
										this.scanner.startPosition = startPosition;
										previousToken = token;
										break;
									}
								}
							} catch (InvalidInputException iie) {
								// skip
							}
						}
						// this was not a valid fall-through tag, hence continue to process the comment normally
						this.scanner.startPosition = startPosition;
			    		this.scanner.currentPosition = restartPosition;
					}
					break;
			}
			int tokenStart = this.scanner.getCurrentTokenStartPosition();
    		int tokenLength = (this.scanner.atEnd() ? this.scanner.eofPosition : this.scanner.currentPosition) - tokenStart;

			// insert space at the beginning if not present
			if (previousToken == -1 ) {
    			addInsertEdit(this.scanner.startPosition, " "); //$NON-NLS-1$
				this.column++;
			}
			// replace space at the beginning if present
			else if (previousToken == SKIP_FIRST_WHITESPACE_TOKEN) {
				addReplaceEdit(spaceStartPosition, this.scanner.startPosition-1, " "); //$NON-NLS-1$
				this.column++;
				spaceStartPosition = -1; // do not use this position to split the comment
			} else {
				// not on the first token
				boolean insertSpace = previousToken == TerminalTokens.TokenNameWHITESPACE;
				if (insertSpace) {
					// count inserted space if any in token length
					tokenLength++;
				}
				// insert new line if max line width is reached and a space was previously encountered
				if (spaceStartPosition > 0 && (this.column+tokenLength) > maxColumn) {
					this.lastNumberOfNewLines++;
					this.line++;
					if (newLineString == null) {
						this.tempBuffer.setLength(0);
						this.tempBuffer.append(this.lineSeparator);
						this.column = 1;
						if (!this.formatter.preferences.never_indent_line_comments_on_first_column) {
							printIndentationIfNecessary(this.tempBuffer);
						}
					    this.tempBuffer.append(LINE_COMMENT_PREFIX);
						this.column += LINE_COMMENT_PREFIX_LENGTH;
						newLineString = this.tempBuffer.toString();
				    	firstColumn = this.column;
					} else {
						this.column = firstColumn;
					}
					if (lastTokenEndPosition > spaceEndPosition) {
						this.column += lastTokenEndPosition - (spaceEndPosition + 1); // add all previous tokens lengths since last space
					}
					if (this.edits[this.editsIndex-1].offset == spaceStartPosition) {
						// previous space was already edited, so remove it
						this.editsIndex--;
					}
					addReplaceEdit(spaceStartPosition, spaceEndPosition, newLineString);
					spaceStartPosition = -1;
					if (insertSpace) {
						tokenLength--; // reduce token length as the space will be replaced by the new line
					}
				}
				// replace space if needed
				else if (insertSpace) {
					addReplaceEdit(spaceStartPosition, this.scanner.startPosition-1, " "); //$NON-NLS-1$
				}
			}
			// update column position and store info of the current token
			this.column += tokenLength;
			previousToken = token;
			lastTokenEndPosition = this.scanner.currentPosition;
		}
		this.scanner.skipComments = false;

		// Skip separator if the comment is not at the end of file
		this.indentationLevel = indentLevel;
		this.numberOfIndentations = indentations;
		this.lastNumberOfNewLines = 0;
		this.scanner.resetTo(lastTokenEndPosition, commentEnd);
		while (!this.scanner.atEnd()) {
			spaceEndPosition = this.scanner.currentPosition;
			this.scanner.getNextChar();
			if (this.scanner.currentCharacter == '\n' || this.scanner.currentCharacter == '\r') {
				// line comment is normally ended with new line
				this.column = 1;
				this.line++;
				this.lastNumberOfNewLines++;
				break;
			}
		}

		// Replace the line separator at the end of the comment if any...
		int startReplace = previousToken == SKIP_FIRST_WHITESPACE_TOKEN ? spaceStartPosition : lastTokenEndPosition;
		if (this.column == 1 && commentEnd >= startReplace) {
			addReplaceEdit(startReplace, commentEnd, this.formatter.preferences.line_separator);
		}
	}

