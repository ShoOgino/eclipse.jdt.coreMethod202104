	/**
	 * Locate declaration in the current class file. This class file is always in a jar.
	 */
	public void locateMatchesInClassFile() throws CoreException {
		org.eclipse.jdt.internal.core.ClassFile classFile = (org.eclipse.jdt.internal.core.ClassFile)this.openable;
		IBinaryType info = this.locator.getBinaryInfo(classFile, this.resource);
		if (info == null) 
			return; // unable to go further
	
		// check class definition
		BinaryType binaryType = (BinaryType)classFile.getType();
		if (this.locator.pattern.matchesBinary(info, null)) {
			this.locator.reportBinaryMatch(binaryType, info, IJavaSearchResultCollector.EXACT_MATCH);
		}
	
		boolean compilationAborted = false;
		if (this.locator.pattern.mustResolve) {
			// resolve
			BinaryTypeBinding binding = null;
			try {
				binding = this.locator.cacheBinaryType(binaryType);
				if (binding != null) {
					// filter out element not in hierarchy scope
					if (!this.locator.typeInHierarchy(binding)) {
						return;
					}
		
					// check methods
					MethodBinding[] methods = binding.methods();
					for (int i = 0; i < methods.length; i++) {
						MethodBinding method = methods[i];
						int level = this.locator.pattern.matchLevel(method);
						switch (level) {
							case SearchPattern.IMPOSSIBLE_MATCH:
							case SearchPattern.INACCURATE_MATCH:
								break;
							default:
								IMethod methodHandle = 
									binaryType.getMethod(
										new String(method.isConstructor() ? binding.compoundName[binding.compoundName.length-1] : method.selector),
										Signature.getParameterTypes(new String(method.signature()).replace('/', '.'))
									);
								this.locator.reportBinaryMatch(
									methodHandle, 
									info, 
									level == SearchPattern.ACCURATE_MATCH ? 
										IJavaSearchResultCollector.EXACT_MATCH : 
										IJavaSearchResultCollector.POTENTIAL_MATCH);
						}
					}
			
					// check fields
					FieldBinding[] fields = binding.fields();
					for (int i = 0; i < fields.length; i++) {
						FieldBinding field = fields[i];
						int level = this.locator.pattern.matchLevel(field);
						switch (level) {
							case SearchPattern.IMPOSSIBLE_MATCH:
							case SearchPattern.INACCURATE_MATCH:
								break;
							default:
								IField fieldHandle = binaryType.getField(new String(field.name));
								this.locator.reportBinaryMatch(
									fieldHandle, 
									info, 
									level == SearchPattern.ACCURATE_MATCH ? 
										IJavaSearchResultCollector.EXACT_MATCH : 
										IJavaSearchResultCollector.POTENTIAL_MATCH);
						}
					}
				}
			} catch (AbortCompilation e) {
				binding = null;
			}
	
			// no need to check binary info if resolve was successful
			compilationAborted = binding == null;
			if (!compilationAborted) return;
		}
	
		// if compilation was aborted it is a problem with the class path: 
		// report as a potential match if binary info matches the pattern
		int accuracy = compilationAborted ? IJavaSearchResultCollector.POTENTIAL_MATCH : IJavaSearchResultCollector.EXACT_MATCH;
		
		// check methods
		IBinaryMethod[] methods = info.getMethods();
		int length = methods == null ? 0 : methods.length;
		for (int i = 0; i < length; i++) {
			IBinaryMethod method = methods[i];
			if (this.locator.pattern.matchesBinary(method, info)) {
				IMethod methodHandle = 
					binaryType.getMethod(
						new String(method.isConstructor() ? info.getName() : method.getSelector()),
						Signature.getParameterTypes(new String(method.getMethodDescriptor()).replace('/', '.'))
					);
				this.locator.reportBinaryMatch(methodHandle, info, accuracy);
			}
		}
	
		// check fields
		IBinaryField[] fields = info.getFields();
		length = fields == null ? 0 : fields.length;
		for (int i = 0; i < length; i++) {
			IBinaryField field = fields[i];
			if (this.locator.pattern.matchesBinary(field, info)) {
				IField fieldHandle = binaryType.getField(new String(field.getName()));
				this.locator.reportBinaryMatch(fieldHandle, info, accuracy);
			}
		}
	}

