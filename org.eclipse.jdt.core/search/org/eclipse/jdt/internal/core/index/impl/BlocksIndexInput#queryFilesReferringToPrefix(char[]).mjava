	public String[] queryFilesReferringToPrefix(char[] prefix) throws IOException {
		open();
		
		int blockLoc = summary.getFirstBlockLocationForPrefix(prefix);
		if (blockLoc < 0) return null;
			
		// each filename must be returned already once
		org.eclipse.jdt.internal.compiler.util.HashtableOfInt fileMatches = new org.eclipse.jdt.internal.compiler.util.HashtableOfInt(20);
		int count = 0; 
		while(blockLoc >= 0){
			IndexBlock block = getIndexBlock(summary.getBlockNum(blockLoc));
			block.reset();
			boolean found = false;
			WordEntry entry = new WordEntry();
			while (block.nextEntry(entry)) {
				if (CharOperation.prefixEquals(prefix, entry.getWord()/*, isCaseSensitive*/)) {
					int [] refs = entry.getRefs();
					for (int i = 0, max = refs.length; i < max; i++){
						int ref = refs[i];
						if (!fileMatches.containsKey(ref)){
							count++;
							fileMatches.put(ref, getIndexedFile(ref));
						}
					}
					found = true;
				} else {
					if (found) break;
				}
			}
			/* consider next block ? */
			blockLoc = summary.getNextBlockLocationForPrefix(prefix, blockLoc);				
		}
		/* extract indexed files */
		String[] paths = new String[count];
		Object[] indexedFiles = fileMatches.valueTable;
		for (int i = 0, index = 0, max = indexedFiles.length; i < max; i++){
			IndexedFile indexedFile = (IndexedFile) indexedFiles[i];
			if (indexedFile != null){
				paths[index++] = indexedFile.getPath();
			}
		}	
		return paths;
	}

