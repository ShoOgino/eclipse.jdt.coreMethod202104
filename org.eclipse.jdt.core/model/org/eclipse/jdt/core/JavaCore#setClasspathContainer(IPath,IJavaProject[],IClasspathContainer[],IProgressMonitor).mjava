	/** 
	 * Bind a container reference path to some actual containers (<code>IClasspathContainer</code>).
	 * This API must be invoked whenever changes in container need to be reflected onto the JavaModel.
	 * Containers can have distinct values in different projects, therefore this API considers a
	 * set of projects with their respective containers.
	 * <p>
	 * <code>containerPath</code> is the path under which these values can be referenced through
	 * container classpath entries (<code>IClasspathEntry#CPE_CONTAINER</code>). A container path 
	 * is formed by a first ID segment followed with extra segments, which can be used as additional hints
	 * for the resolution. The container ID is used to identify a <code>ClasspathContainerInitializer</code> 
	 * registered on the extension point "org.eclipse.jdt.core.classpathContainerInitializer".
	 * <p>
	 * There is no assumption that each individual container value passed in argument 
	 * (<code>respectiveContainers</code>) must answer the exact same path when requested 
	 * <code>IClasspathContainer#getPath</code>. 
	 * Indeed, the containerPath is just an indication for resolving it to an actual container object. It can be 
	 * delegated to a <code>ClasspathContainerInitializer</code>, which can be activated through the extension
	 * point "org.eclipse.jdt.core.ClasspathContainerInitializer"). 
	 * <p>
	 * In reaction to changing container values, the JavaModel will be updated to reflect the new
	 * state of the updated container. A combined Java element delta will be notified to describe the corresponding 
	 * classpath changes resulting from the container update. This operation is batched, and automatically eliminates
	 * unnecessary updates (new container is same as old one). This operation acquires a lock on the workspace's root.
	 * <p>
	 * This functionality cannot be used while the workspace is locked, since
	 * it may create/remove some resource markers.
	 * <p>
	 * Classpath container values are persisted locally to the workspace, but 
	 * are not preserved from a session to another. It is thus highly recommended to register a 
	 * <code>ClasspathContainerInitializer</code> for each referenced container 
	 * (through the extension point "org.eclipse.jdt.core.ClasspathContainerInitializer").
	 * <p>
	 * Note: setting a container to <code>null</code> will cause it to be lazily resolved again whenever
	 * its value is required. In particular, this will cause a registered initializer to be invoked
	 * again.
	 * <p>
	 * @param containerPath - the name of the container reference, which is being updated
	 * @param affectedProjects - the set of projects for which this container is being bound
	 * @param respectiveContainers - the set of respective containers for the affected projects
	 * @param monitor a monitor to report progress
	 * @throws JavaModelException
	 * @see ClasspathContainerInitializer
	 * @see #getClasspathContainer(IPath, IJavaProject)
	 * @see IClasspathContainer
	 * @since 2.0
	 */
	public static void setClasspathContainer(final IPath containerPath, IJavaProject[] affectedProjects, IClasspathContainer[] respectiveContainers, IProgressMonitor monitor) throws JavaModelException {

		if (affectedProjects.length != respectiveContainers.length) Assert.isTrue(false, "Projects and containers collections should have the same size"); //$NON-NLS-1$
	
		if (monitor != null && monitor.isCanceled()) return;
	
		if (JavaModelManager.CP_RESOLVE_VERBOSE){
			Util.verbose(
				"CPContainer SET  - setting container\n" + //$NON-NLS-1$
				"	container path: " + containerPath + '\n' + //$NON-NLS-1$
				"	projects: {" +//$NON-NLS-1$
				org.eclipse.jdt.internal.compiler.util.Util.toString(
					affectedProjects, 
					new org.eclipse.jdt.internal.compiler.util.Util.Displayable(){ 
						public String displayString(Object o) { return ((IJavaProject) o).getElementName(); }
					}) +
				"}\n	values: {\n"  +//$NON-NLS-1$
				org.eclipse.jdt.internal.compiler.util.Util.toString(
					respectiveContainers, 
					new org.eclipse.jdt.internal.compiler.util.Util.Displayable(){ 
						public String displayString(Object o) { 
							StringBuffer buffer = new StringBuffer("		"); //$NON-NLS-1$
							if (o == null) {
								buffer.append("<null>"); //$NON-NLS-1$
								return buffer.toString();
							}
							IClasspathContainer container = (IClasspathContainer) o;
							buffer.append(container.getDescription());
							buffer.append(" {\n"); //$NON-NLS-1$
							IClasspathEntry[] entries = container.getClasspathEntries();
							if (entries != null){
								for (int i = 0; i < entries.length; i++){
									buffer.append(" 			"); //$NON-NLS-1$
									buffer.append(entries[i]); 
									buffer.append('\n'); 
								}
							}
							buffer.append(" 		}"); //$NON-NLS-1$
							return buffer.toString();
						}
					}) +
				"\n	}\n	invocation stack trace:"); //$NON-NLS-1$
				new Exception("<Fake exception>").printStackTrace(System.out); //$NON-NLS-1$
		}
		
		JavaModelManager manager = JavaModelManager.getJavaModelManager();
		if (manager.containerPutIfInitializingWithSameEntries(containerPath, affectedProjects, respectiveContainers))
			return;

		final int projectLength = affectedProjects.length;	
		final IJavaProject[] modifiedProjects;
		System.arraycopy(affectedProjects, 0, modifiedProjects = new IJavaProject[projectLength], 0, projectLength);
		final IClasspathEntry[][] oldResolvedPaths = new IClasspathEntry[projectLength][];
			
		// filter out unmodified project containers
		int remaining = 0;
		for (int i = 0; i < projectLength; i++){
	
			if (monitor != null && monitor.isCanceled()) return;
	
			JavaProject affectedProject = (JavaProject) affectedProjects[i];
			IClasspathContainer newContainer = respectiveContainers[i];
			if (newContainer == null) newContainer = JavaModelManager.CONTAINER_INITIALIZATION_IN_PROGRESS; // 30920 - prevent infinite loop
			boolean found = false;
			if (JavaProject.hasJavaNature(affectedProject.getProject())){
				IClasspathEntry[] rawClasspath = affectedProject.getRawClasspath();
				for (int j = 0, cpLength = rawClasspath.length; j <cpLength; j++) {
					IClasspathEntry entry = rawClasspath[j];
					if (entry.getEntryKind() == IClasspathEntry.CPE_CONTAINER && entry.getPath().equals(containerPath)){
						found = true;
						break;
					}
				}
			}
			if (!found){
				modifiedProjects[i] = null; // filter out this project - does not reference the container path, or isnt't yet Java project
				manager.containerPut(affectedProject, containerPath, newContainer);
				continue;
			}
			IClasspathContainer oldContainer = manager.containerGet(affectedProject, containerPath);
			if (oldContainer == JavaModelManager.CONTAINER_INITIALIZATION_IN_PROGRESS) {
//				Map previousContainerValues = (Map)JavaModelManager.getJavaModelManager().previousSessionContainers.get(affectedProject);
//				if (previousContainerValues != null){
//					IClasspathContainer previousContainer = (IClasspathContainer)previousContainerValues.get(containerPath);
//					if (previousContainer != null) {
//						if (JavaModelManager.CP_RESOLVE_VERBOSE){
//							StringBuffer buffer = new StringBuffer();
//							buffer.append("CPContainer INIT - reentering access to project container during its initialization, will see previous value\n"); //$NON-NLS-1$ 
//							buffer.append("	project: " + affectedProject.getElementName() + '\n'); //$NON-NLS-1$
//							buffer.append("	container path: " + containerPath + '\n'); //$NON-NLS-1$
//							buffer.append("	previous value: "); //$NON-NLS-1$
//							buffer.append(previousContainer.getDescription());
//							buffer.append(" {\n"); //$NON-NLS-1$
//							IClasspathEntry[] entries = previousContainer.getClasspathEntries();
//							if (entries != null){
//								for (int j = 0; j < entries.length; j++){
//									buffer.append(" 		"); //$NON-NLS-1$
//									buffer.append(entries[j]); 
//									buffer.append('\n'); 
//								}
//							}
//							buffer.append(" 	}"); //$NON-NLS-1$
//							Util.verbose(buffer.toString());
//						}
//						JavaModelManager.getJavaModelManager().containerPut(affectedProject, containerPath, previousContainer); 
//					}
//					oldContainer = null; //33695 - cannot filter out restored container, must update affected project to reset cached CP
//				} else {
					oldContainer = null;
//				}
			}
			if (oldContainer != null && oldContainer.equals(respectiveContainers[i])){
				modifiedProjects[i] = null; // filter out this project - container did not change
				continue;
			}
			remaining++; 
			oldResolvedPaths[i] = affectedProject.getResolvedClasspath(true/*ignoreUnresolvedEntry*/, false/*don't generateMarkerOnError*/, false/*don't returnResolutionInProgress*/);
			manager.containerPut(affectedProject, containerPath, newContainer);
		}
		
		if (remaining == 0) return;
		
		// trigger model refresh
		try {
			final boolean canChangeResources = !ResourcesPlugin.getWorkspace().isTreeLocked();
			JavaCore.run(new IWorkspaceRunnable() {
				public void run(IProgressMonitor progressMonitor) throws CoreException {
					for(int i = 0; i < projectLength; i++){
		
						if (progressMonitor != null && progressMonitor.isCanceled()) return;
		
						JavaProject affectedProject = (JavaProject)modifiedProjects[i];
						if (affectedProject == null) continue; // was filtered out
						
						if (JavaModelManager.CP_RESOLVE_VERBOSE){
							Util.verbose(
								"CPContainer SET  - updating affected project due to setting container\n" + //$NON-NLS-1$
								"	project: " + affectedProject.getElementName() + '\n' + //$NON-NLS-1$
								"	container path: " + containerPath); //$NON-NLS-1$
						}

						// force a refresh of the affected project (will compute deltas)
						affectedProject.setRawClasspath(
								affectedProject.getRawClasspath(),
								SetClasspathOperation.REUSE_PATH,
								progressMonitor,
								canChangeResources,
								oldResolvedPaths[i],
								false, // updating - no need for early validation
								false); // updating - no need to save
					}
				}
			},
			null/*no need to lock anything*/,
			monitor);
		} catch(CoreException e) {
			if (JavaModelManager.CP_RESOLVE_VERBOSE){
				Util.verbose(
					"CPContainer SET  - FAILED DUE TO EXCEPTION\n" + //$NON-NLS-1$
					"	container path: " + containerPath, //$NON-NLS-1$
					System.err);
				e.printStackTrace();
			}
			if (e instanceof JavaModelException) {
				throw (JavaModelException)e;
			} else {
				throw new JavaModelException(e);
			}
		} finally {
			for (int i = 0; i < projectLength; i++) {
				if (respectiveContainers[i] == null) {
					manager.containerPut(affectedProjects[i], containerPath, null); // reset init in progress marker
				}
			}
		}
					
	}

