/**
 * Extracts the parameter type signatures from the given method signature. 
 * The method signature is expected to be dot-based.
 *
 * @param methodSignature the method signature
 * @return the list of parameter type signatures
 * @exception IllegalArgumentException if the signature is syntactically
 *   incorrect
 * 
 * @since 2.0
 */
public static char[][] getParameterTypes(char[] methodSignature) throws IllegalArgumentException {
	try {
		int count = getParameterCount(methodSignature);
		char[][] result = new char[count][];
		if (count == 0)
			return result;
		int i = CharOperation.indexOf(C_PARAM_START, methodSignature) + 1;
		count = 0;
		int start = i;
		for (;;) {
			char c = methodSignature[i++];
			switch (c) {
				case C_ARRAY :
					// array depth is i - start;
					break;
				case C_BOOLEAN :
				case C_BYTE :
				case C_CHAR :
				case C_DOUBLE :
				case C_FLOAT :
				case C_INT :
				case C_LONG :
				case C_SHORT :
				case C_VOID :
					// common case of base types
					if (i - start == 1) {
						switch (c) {
							case C_BOOLEAN :
								result[count++] = new char[] {C_BOOLEAN};
								break;
							case C_BYTE :
								result[count++] = new char[] {C_BYTE};
								break;
							case C_CHAR :
								result[count++] = new char[] {C_CHAR};
								break;
							case C_DOUBLE :
								result[count++] = new char[] {C_DOUBLE};
								break;
							case C_FLOAT :
								result[count++] = new char[] {C_FLOAT};
								break;
							case C_INT :
								result[count++] = new char[] {C_INT};
								break;
							case C_LONG :
								result[count++] = new char[] {C_LONG};
								break;
							case C_SHORT :
								result[count++] = new char[] {C_SHORT};
								break;
							case C_VOID :
								result[count++] = new char[] {C_VOID};
								break;
						}
					} else {
						result[count++] = CharOperation.subarray(methodSignature, start, i);
					}
					start = i;
					break;
				case C_TYPE_VARIABLE :
				case C_RESOLVED :
				case C_UNRESOLVED :
					// TODO (jeem) - rework to handle type arguments like QList<QString;>;
					i = CharOperation.indexOf(C_SEMICOLON, methodSignature, i) + 1;
					if (i == 0)
						throw new IllegalArgumentException();
					result[count++] = CharOperation.subarray(methodSignature, start, i);
					start = i;
					break;
				case C_PARAM_END:
					return result;
				default :
					throw new IllegalArgumentException();
			}
		}
	} catch (ArrayIndexOutOfBoundsException e) {
		throw new IllegalArgumentException();
	}
}

