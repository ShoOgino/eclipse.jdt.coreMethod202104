	private void correct(char[] argument) {
		try {
			String source = this.compilationUnit.getSource();
			Scanner scanner = new Scanner();
			scanner.setSource(source.toCharArray());
			
			scanner.resetTo(this.correctionStart, this.correctionEnd);
			int token = 0;
			char[] argumentSource = CharOperation.NO_CHAR;
			
			// search last segment position
			while(true) {
				token = scanner.getNextToken();
				if (token == TerminalTokens.TokenNameEOF) return;
				
				char[] tokenSource = scanner.getCurrentTokenSource();
				
				argumentSource = CharOperation.concat(argumentSource, tokenSource);
				if(!CharOperation.prefixEquals(argumentSource, argument))
					return;
				
				if(CharOperation.equals(argument, argumentSource)) {
					this.correctionStart = scanner.startPosition;
					this.correctionEnd = scanner.currentPosition;
					this.prefixLength = CharOperation.lastIndexOf('.', argument) + 1;
					break;
				}
				
			}
		
			// search completion position
			int completionPosition = this.correctionStart;
			scanner.resetTo(completionPosition, this.correctionEnd);
			int position = completionPosition;
			
			for (int i = 0; i < 4; i++) {
				if(scanner.getNextCharAsJavaIdentifierPart()) {
					completionPosition = position;
					position = scanner.currentPosition;
				} else {
					break;
				}
			}
			Hashtable oldOptions = JavaCore.getOptions();
			try {
				Hashtable options = new Hashtable(oldOptions);
				options.put(JavaCore.CODEASSIST_CAMEL_CASE_MATCH, JavaCore.DISABLED);
				JavaCore.setOptions(options);
				
				this.compilationUnit.codeComplete(
					completionPosition,
					this.completionRequestor
				);
			} finally {
				JavaCore.setOptions(oldOptions);
			}
		} catch (JavaModelException e) {
			return;
		} catch (InvalidInputException e) {
			return;
		}
	}

