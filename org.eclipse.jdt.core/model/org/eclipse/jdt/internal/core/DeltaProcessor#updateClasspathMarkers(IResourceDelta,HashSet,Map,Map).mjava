	/*
	 * Check whether .classpath files are affected by the given delta.
	 * Creates/removes problem markers if needed.
	 * Remember the affected projects in the given set.
	 */
	private void updateClasspathMarkers(IResourceDelta delta, HashSet affectedProjects, Map preferredClasspaths, Map preferredOutputs) {
		IResource resource = delta.getResource();
		boolean processChildren = false;

		switch (resource.getType()) {
	
			case IResource.ROOT :
				if (delta.getKind() == IResourceDelta.CHANGED) {
					processChildren = true;
				}
				break;
			case IResource.PROJECT :
				IProject project = (IProject)resource;
				int kind = delta.getKind();
				boolean isJavaProject = JavaProject.hasJavaNature(project);
				switch (kind) {
					case IResourceDelta.ADDED:
						processChildren = isJavaProject;
						affectedProjects.add(project.getFullPath());
						break;
					case IResourceDelta.CHANGED:
						processChildren = isJavaProject;
						if ((delta.getFlags() & IResourceDelta.OPEN) != 0) {
							// project opened or closed: remember  project and its dependents
							affectedProjects.add(project.getFullPath());
							if (isJavaProject) {
								JavaProject javaProject = (JavaProject)JavaCore.create(project);
								javaProject.updateClasspathMarkers(preferredClasspaths, preferredOutputs); // in case .classpath got modified while closed
							}
						} else if ((delta.getFlags() & IResourceDelta.DESCRIPTION) != 0) {
							boolean wasJavaProject = this.state.findJavaProject(project.getName()) != null;
							if (wasJavaProject && !isJavaProject) {
								// project no longer has Java nature, discard Java related obsolete markers
								affectedProjects.add(project.getFullPath());
								// flush classpath markers
								JavaProject javaProject = (JavaProject)JavaCore.create(project);
								javaProject.
									flushClasspathProblemMarkers(
										true, // flush cycle markers
										true  //flush classpath format markers
									);
									
								// remove problems and tasks created  by the builder
								JavaBuilder.removeProblemsAndTasksFor(project);
							}
						} else if (isJavaProject) {
							// check if all entries exist
							try {
								JavaProject javaProject = (JavaProject)JavaCore.create(project);
								javaProject.getResolvedClasspath(true/*ignoreUnresolvedEntry*/, 	true/*generateMarkerOnError*/, false/*don't returnResolutionInProgress*/);
							} catch (JavaModelException e) {
								// project doesn't exist: ignore
							}
						}
						break;
					case IResourceDelta.REMOVED:
						affectedProjects.add(project.getFullPath());
						break;
				}
				break;
			case IResource.FILE :
				/* check classpath file change */
				IFile file = (IFile) resource;
				if (file.getName().equals(JavaProject.CLASSPATH_FILENAME)) {
					affectedProjects.add(file.getProject().getFullPath());
					JavaProject javaProject = (JavaProject)JavaCore.create(file.getProject());
					javaProject.updateClasspathMarkers(preferredClasspaths, preferredOutputs);
					break;
				}
//				/* check custom preference file change */
//				if (file.getName().equals(JavaProject.PREF_FILENAME)) {
//					reconcilePreferenceFileUpdate(delta, file, project);
//					break;
//				}
				break;
		}
		if (processChildren) {
			IResourceDelta[] children = delta.getAffectedChildren();
			for (int i = 0; i < children.length; i++) {
				updateClasspathMarkers(children[i], affectedProjects, preferredClasspaths, preferredOutputs);
			}
		}
	}

