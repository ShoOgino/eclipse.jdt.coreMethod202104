	/*
	 * Notification that some resource changes have happened
	 * on the platform, and that the Java Model should update any required
	 * internal structures such that its elements remain consistent.
	 * Translates <code>IResourceDeltas</code> into <code>IJavaElementDeltas</code>.
	 *
	 * @see IResourceDelta
	 * @see IResource 
	 */
	public void resourceChanged(IResourceChangeEvent event) {
	
		if (event.getSource() instanceof IWorkspace) {
			int eventType = this.overridenEventType == -1 ? event.getType() : this.overridenEventType;
			IResource resource = event.getResource();
			IResourceDelta delta = event.getDelta();
			
			switch(eventType){
				case IResourceChangeEvent.PRE_DELETE :
					try {
						if(resource.getType() == IResource.PROJECT 
							&& ((IProject) resource).hasNature(JavaCore.NATURE_ID)) {
								
							deleting((IProject)resource);
						}
					} catch(CoreException e){
						// project doesn't exist or is not open: ignore
					}
					return;
					
				case IResourceChangeEvent.POST_CHANGE :
					if (isAffectedBy(delta)) { // avoid populating for SYNC or MARKER deltas
						try {
							try {
								stopDeltas();
								checkProjectsBeingAddedOrRemoved(delta);
								
								// generate classpath change deltas
								if (this.classpathChanges.size() > 0) {
									boolean hasDelta = this.currentDelta != null;
									JavaElementDelta javaDelta = currentDelta();
									Iterator changes = this.classpathChanges.values().iterator();
									while (changes.hasNext()) {
										ClasspathChange change = (ClasspathChange) changes.next();
										int result = change.generateDelta(javaDelta);
										if ((result & ClasspathChange.HAS_DELTA) != 0) {
											hasDelta = true;
											change.requestIndexing();
											this.state.addClasspathValidation(change.project);
										}
										if ((result & ClasspathChange.HAS_PROJECT_CHANGE) != 0) {
											this.state.addProjectReferenceChange(change.project, change.oldResolvedClasspath);
										}
									}
									this.classpathChanges.clear();
									if (!hasDelta)
										this.currentDelta = null;
								}
								
								// generate external archive change deltas
								if (this.refreshedElements != null) {
									createExternalArchiveDelta(null);
								}
								
								// generate Java deltas from resource changes
								IJavaElementDelta translatedDelta = processResourceDelta(delta);
								if (translatedDelta != null) { 
									registerJavaModelDelta(translatedDelta);
								}
							} finally {
								this.sourceElementParserCache = null; // don't hold onto parser longer than necessary
								startDeltas();
							}
							IElementChangedListener[] listeners;
							int listenerCount;
							synchronized (this.state) {
								listeners = this.state.elementChangedListeners;
								listenerCount = this.state.elementChangedListenerCount;
							}
							notifyTypeHierarchies(listeners, listenerCount);
							fire(null, ElementChangedEvent.POST_CHANGE);
						} finally {
							// workaround for bug 15168 circular errors not reported 
							this.state.resetOldJavaProjectNames();
							this.oldRoots = null;
						}
					}
					return;
					
				case IResourceChangeEvent.PRE_BUILD :
					if(!isAffectedBy(delta))
						return; // avoid populating for SYNC or MARKER deltas

					// create classpath markers if necessary
					boolean needCycleValidation = validateClasspaths(delta);
					ClasspathValidation[] validations = this.state.removeClasspathValidations();
					if (validations != null) {
						for (int i = 0, length = validations.length; i < length; i++) {
							ClasspathValidation validation = validations[i];
							validation.validate();
						}
					}
					
					// update project references if necessary
				    ProjectReferenceChange[] projectRefChanges = this.state.removeProjectReferenceChanges();
					if (projectRefChanges != null) {
					    for (int i = 0, length = projectRefChanges.length; i < length; i++) {
					        try {
						        projectRefChanges[i].updateProjectReferencesIfNecessary();
					        } catch(JavaModelException e) {
					            // project doesn't exist any longer, continue with next one
					        }
					    }
					}
					
					if (needCycleValidation || projectRefChanges != null) {
						// update all cycle markers since the project references changes may have affected cycles
						try {
							JavaProject.validateCycles(null);
						} catch (JavaModelException e) {
							// a project no longer exists
						}
					}
					
					JavaModel.flushExternalFileCache();
					JavaBuilder.buildStarting();
					
					// does not fire any deltas
					return;

				case IResourceChangeEvent.POST_BUILD :
					JavaBuilder.buildFinished();
					return;
			}
		}
	}

