		int nextToken() {
			int previousTokenEnd = this.index;
			this.start = this.index;
			int length = this.source.length;
			while (this.index <= length) {
				char currentChar = this.index == length ? Character.MIN_VALUE : this.source[this.index];
				switch (currentChar) {
					case 'B':
					case 'C':
					case 'D':
					case 'F':
					case 'I':
					case 'J':
					case 'N':
					case 'S':
					case 'V':
					case 'Z':
						// base type
						if (this.index == previousTokenEnd 
								&& (this.index == 0 || this.source[this.index-1] != '.')) { // case of field or method starting with one of the character above
							this.index++;
							this.token = BASE_TYPE;
							return this.token;
						}
						break;
					case 'L':
					case 'T':
						if (this.index == previousTokenEnd) {
							this.start = this.index+1;
						}
						break;
					case ';':
						if (this.index == previousTokenEnd) {
							this.start = this.index+1;
							previousTokenEnd = this.start;
						} else {
							this.token = TYPE;
							return this.token;
						}
						break;
					case '^':
						if (this.index == previousTokenEnd) {
							this.index++;
							this.start = this.index;
							while (this.index < length && Character.isDigit(this.source[this.index]))
								this.index++;
							this.token = FLAGS;
							return this.token;
						} else {
							switch (this.token) {
								case METHOD:
								case LOCAL_VAR:
									this.token = LOCAL_VAR;
									break;
								case TYPE:
								case BASE_TYPE:
									if (this.index > this.start && this.source[this.start-1] == '.')
										this.token = FIELD;
									break;
							}							
							return this.token;
						}
					case '$':
					case '~':
						if (this.index == previousTokenEnd) {
							this.start = this.index+1;
						} else {
							this.token = TYPE;
							return this.token;
						}
						break;
					case '.':
					case '%':
					case ':':
					case '>':
						this.start = this.index+1;
						previousTokenEnd = this.start;
						break;
					case '[':
						while (this.index < length && this.source[this.index] == '[')
							this.index++;
						this.token = ARRAY;
						return this.token;
					case '<':
						if (this.start > 0) {
							switch (this.source[this.start-1]) {
								case '.':
									if (this.source[this.start-2] == '>')
										// case of member type where enclosing type is parameterized
										this.token = TYPE;
									else
										this.token = METHOD;
									return this.token;
								default:
									if (this.index == previousTokenEnd) {
										this.start = this.index+1;
										previousTokenEnd = this.start;
									} else {
										this.token = TYPE;
										return this.token;
									}
							}
						} 
						break;
					case '(':
						this.token = METHOD;
						return this.token;
					case ')':
						if (this.token == TYPE) {
							this.token = FIELD;
							return this.token;
						}
						this.start = this.index+1;
						previousTokenEnd = this.start;
						break;
					case '#':
						if (this.index == previousTokenEnd) {
							this.start = this.index+1;
							previousTokenEnd = this.start;
						} else {
							this.token = LOCAL_VAR;
							return this.token;
						}
						break;
					case Character.MIN_VALUE:
						switch (this.token) {
							case START:
								this.token = PACKAGE;
								break;
							case METHOD:
							case LOCAL_VAR:
								this.token = LOCAL_VAR;
								break;
							case TYPE:
								if (this.index > this.start && this.source[this.start-1] == '.')
									this.token = FIELD;
								else
									this.token = END;
								break;
							case WILDCARD:
								this.token = TYPE;
								break;
							default:
								this.token = END;
								break;
						}
						return this.token;
					case '*':
					case '+':
					case '-':
						this.index++;
						this.token = WILDCARD;
						return this.token;
					case '!':
					case '&':
						this.index++;
						this.token = CAPTURE;
						return this.token;
				}
				this.index++;
			}
			this.token = END;
			return this.token;
		}

