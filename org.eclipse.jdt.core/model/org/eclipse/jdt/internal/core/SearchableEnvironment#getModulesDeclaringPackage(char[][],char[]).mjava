	/**
	 * @see org.eclipse.jdt.internal.compiler.env.IModuleAwareNameEnvironment#getModulesDeclaringPackage(char[][], char[])
	 */
	@Override
	public char[][] getModulesDeclaringPackage(char[][] packageName, char[] moduleName) {
		long start = -1;
		if (NameLookup.VERBOSE)
			start = System.currentTimeMillis();
		try {
			String[] pkgName = Arrays.stream(packageName).map(String::new).toArray(String[]::new);
			LookupStrategy strategy = LookupStrategy.get(moduleName);
			switch (strategy) {
				case Named:
					if (this.knownModuleLocations != null) {
						IPackageFragmentRoot[] moduleContext = findModuleContext(moduleName);
						if (moduleContext != null) {
							// (this.owner != null && this.owner.isPackage(pkgName)) // TODO(SHMOD) see old isPackage
							if (this.nameLookup.isPackage(pkgName, moduleContext)) {
								return new char[][] { moduleName };
							}
						}
					}
					return null;
				case Unnamed:
				case Any:
					// if in pre-9 mode we may still search the unnamed module
					if (this.knownModuleLocations == null) {
						if ((this.owner != null && this.owner.isPackage(pkgName))
								|| this.nameLookup.isPackage(pkgName))
							return new char[][] { ModuleBinding.UNNAMED };
						return null;
					}
					//$FALL-THROUGH$
				case AnyNamed:
					char[][] names = CharOperation.NO_CHAR_CHAR;
					// narrow down candidates of roots (https://bugs.eclipse.org/566498)
					IPackageFragmentRoot[] matchingRoots = this.nameLookup.findPackageFragementRoots(pkgName);
					if(matchingRoots != null) {
						boolean containsUnnamed = false;
						for (IPackageFragmentRoot packageRoot : matchingRoots) {
							IPackageFragmentRoot[] singleton = { packageRoot };
							if (strategy.matches(singleton, locs -> locs[0] instanceof JrtPackageFragmentRoot || getModuleDescription(locs) != null)) {
								if (this.nameLookup.isPackage(pkgName, singleton)) {
									IModuleDescription moduleDescription = getModuleDescription(singleton);
									char[] aName;
									if (moduleDescription != null) {
										aName = moduleDescription.getElementName().toCharArray();
									} else {
										if (containsUnnamed)
											continue;
										containsUnnamed = true;
										aName = ModuleBinding.UNNAMED;
									}
									names = CharOperation.arrayConcat(names, aName);
								}
							}
						}
					}
					return names == CharOperation.NO_CHAR_CHAR ? null : names;
				default:
					throw new IllegalArgumentException("Unexpected LookupStrategy "+strategy); //$NON-NLS-1$
			}
		} finally {
			if (NameLookup.VERBOSE)
				this.timeSpentInGetModulesDeclaringPackage += System.currentTimeMillis()-start;
		}
	}

