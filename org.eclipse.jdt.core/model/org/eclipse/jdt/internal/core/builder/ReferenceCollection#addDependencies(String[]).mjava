void addDependencies(String[] typeNameDependencies) {
	// if each qualified type name is already known then all of its subNames can be skipped
	// and its expected that very few qualified names in typeNameDependencies need to be added
	// but could always take 'p1.p2.p3.X' and make all qualified names 'p1' 'p1.p2' 'p1.p2.p3' 'p1.p2.p3.X', then intern
	char[][][] qNames = new char[typeNameDependencies.length][][];
	for (int i = typeNameDependencies.length; --i >= 0;)
		qNames[i] = CharOperation.splitOn('.', typeNameDependencies[i].toCharArray());
	qNames = internQualifiedNames(qNames);

	next : for (int i = qNames.length; --i >= 0;) {
		char[][] qualifiedTypeName = qNames[i];
		while (!includes(qualifiedTypeName)) {
			if (qualifiedTypeName.length == 1) {
				if (!includes(qualifiedTypeName[0])) {
					int length = this.simpleNameReferences.length;
					System.arraycopy(this.simpleNameReferences, 0, this.simpleNameReferences = new char[length + 1][], 0, length);
					this.simpleNameReferences[length] = qualifiedTypeName[0];
				}
				continue next;
			} else {
				int length = this.qualifiedNameReferences.length;
				System.arraycopy(this.qualifiedNameReferences, 0, this.qualifiedNameReferences = new char[length + 1][][], 0, length);
				this.qualifiedNameReferences[length] = qualifiedTypeName;

				qualifiedTypeName = CharOperation.subarray(qualifiedTypeName, 0, qualifiedTypeName.length - 1);
				char[][][] temp = internQualifiedNames(new char[][][] {qualifiedTypeName});
				if (temp == EmptyQualifiedNames)
					continue next; // qualifiedTypeName is a well known name
				qualifiedTypeName = temp[0];
			}		
		}
	}
}

