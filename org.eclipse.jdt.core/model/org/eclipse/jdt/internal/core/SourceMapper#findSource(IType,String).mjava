	/**
	 * Locates and returns source code for the given (binary) type, in this
	 * SourceMapper's ZIP file, or returns <code>null</code> if source
	 * code cannot be found.
	 * The given simpleSourceFileName is the .java file name (without the enclosing
	 * folder) used to create the given type (e.g. "A.java" for x/y/A$Inner.class)
	 */
	public char[] findSource(IType type, String simpleSourceFileName) {
		long time = 0;
		if (VERBOSE) {
			time = System.currentTimeMillis();
		}
		PackageFragment pkgFrag = (PackageFragment) type.getPackageFragment();
		String name = org.eclipse.jdt.internal.core.util.Util.concatWith(pkgFrag.names, simpleSourceFileName, '/');

		char[] source = null;

		JavaModelManager javaModelManager = JavaModelManager.getJavaModelManager();
		try {
			javaModelManager.cacheZipFiles(this); // Cache any zip files we open during this operation

			if (this.rootPath != null) {
				source = getSourceForRootPath(this.rootPath, name);
				if (source == null) {
					source = getSourceForRootPath("", name); //$NON-NLS-1$
				}
			}
	
			if (source == null) {
				computeAllRootPaths(type);
				if (this.rootPaths != null) {
					loop: for (Iterator iterator = this.rootPaths.iterator(); iterator.hasNext(); ) {
						String currentRootPath = (String) iterator.next();
						if (!currentRootPath.equals(this.rootPath)) {
							source = getSourceForRootPath(currentRootPath, name);
							if (source != null) {
								// remember right root path
								this.rootPath = currentRootPath;
								break loop;
							}
						}
					}
				}
			}
		} finally {
			javaModelManager.flushZipFiles(this); // clean up cached zip files.
		}
		if (VERBOSE) {
			System.out.println("spent " + (System.currentTimeMillis() - time) + "ms for " + type.getElementName()); //$NON-NLS-1$ //$NON-NLS-2$
		}
		return source;
	}

