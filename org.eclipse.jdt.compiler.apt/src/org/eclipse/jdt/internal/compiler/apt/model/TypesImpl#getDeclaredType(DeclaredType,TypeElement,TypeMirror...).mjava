	/* (non-Javadoc)
	 * @see javax.lang.model.util.Types#getDeclaredType(javax.lang.model.type.DeclaredType, javax.lang.model.element.TypeElement, javax.lang.model.type.TypeMirror[])
	 */
	@Override
	public DeclaredType getDeclaredType(DeclaredType containing, TypeElement typeElem,
			TypeMirror... typeArgs) {
		int typeArgsLength = typeArgs.length;
		TypeElementImpl typeElementImpl = (TypeElementImpl) typeElem;
		ReferenceBinding referenceBinding = (ReferenceBinding) typeElementImpl._binding;
		TypeVariableBinding[] typeVariables = referenceBinding.typeVariables();
		int typeVariablesLength = typeVariables.length;
		DeclaredTypeImpl declaredTypeImpl = (DeclaredTypeImpl) containing;
		ReferenceBinding enclosingType = (ReferenceBinding) declaredTypeImpl._binding;
		if (typeArgsLength == 0) {
			if (referenceBinding.isGenericType()) {
				// must return a raw type
				return Factory.newDeclaredType(this._env.getLookupEnvironment().createRawType(referenceBinding, enclosingType));
			}
			// TODO (see how to create a member type binding
			throw new UnsupportedOperationException("NYI: TypesImpl.getDeclaredType(...) for member types"); //$NON-NLS-1$
		} else if (typeArgsLength != typeVariablesLength) {
			throw new IllegalArgumentException("Number of typeArguments doesn't match the number of formal parameters of typeElem"); //$NON-NLS-1$
		}
		TypeBinding[] typeArguments = new TypeBinding[typeArgsLength];
		for (int i = 0; i < typeArgsLength; i++) {
			TypeMirrorImpl typeMirrorImpl = (TypeMirrorImpl) typeArgs[i];
			Binding binding = typeMirrorImpl._binding;
			if (!(binding instanceof ReferenceBinding)) {
				throw new IllegalArgumentException("Invalid type for a type arguments : " + typeMirrorImpl); //$NON-NLS-1$
			}
			typeArguments[i] = (ReferenceBinding) binding;
		}
		return Factory.newDeclaredType(
				this._env.getLookupEnvironment().createParameterizedType(referenceBinding, typeArguments, enclosingType));
	}

